"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkraiden_dapp"] = self["webpackChunkraiden_dapp"] || []).push([["node_modules_pouchdb-adapter-indexeddb_lib_index_es_js"],{

/***/ "../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js":
/*!*****************************************************************!*\
  !*** ../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pouchdb-binary-utils */ \"../node_modules/pouchdb-binary-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pouchdb-adapter-utils */ \"../node_modules/pouchdb-adapter-utils/lib/index.es.js\");\n/* harmony import */ var pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pouchdb-md5 */ \"../node_modules/pouchdb-md5/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pouchdb-utils */ \"../node_modules/pouchdb-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pouchdb-errors */ \"../node_modules/pouchdb-errors/lib/index.es.js\");\n/* harmony import */ var pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pouchdb-merge */ \"../node_modules/pouchdb-merge/lib/index.es.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ../node_modules/console-browserify/index.js */ \"../node_modules/console-browserify/index.js\");\n\n\n\n\n\n\n\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\n\n// These are the same as bellow but without the global flag\n// we want to use RegExp.test because it's really fast, but the global flag\n// makes the regex const stateful (seriously) as it walked through all instances\nvar TEST_KEY_INVALID = /^[^a-zA-Z_$]|[^a-zA-Z0-9_$]+/;\nvar TEST_PATH_INVALID = /\\\\.|(^|\\.)[^a-zA-Z_$]|[^a-zA-Z0-9_$.]+/;\nfunction needsSanitise(name, isPath) {\n  if (isPath) {\n    return TEST_PATH_INVALID.test(name);\n  } else {\n    return TEST_KEY_INVALID.test(name);\n  }\n}\n\n//\n// IndexedDB only allows valid JS names in its index paths, whereas JSON allows\n// for any string at all. This converts invalid JS names to valid ones, to allow\n// for them to be indexed.\n//\n// For example, \"foo-bar\" is a valid JSON key, but cannot be a valid JS name\n// (because that would be read as foo minus bar).\n//\n// Very high level rules for valid JS names are:\n//  - First character cannot start with a number\n//  - Otherwise all characters must be be a-z, A-Z, 0-9, $ or _.\n//  - We allow . unless the name represents a single field, as that represents\n//    a deep index path.\n//\n// This is more aggressive than it needs to be, but also simpler.\n//\nvar KEY_INVALID = new RegExp(TEST_KEY_INVALID.source, 'g');\nvar PATH_INVALID = new RegExp(TEST_PATH_INVALID.source, 'g');\nvar SLASH = '\\\\'.charCodeAt(0);\nconst IS_DOT = '.'.charCodeAt(0);\n\nfunction sanitise(name, isPath) {\n  var correctCharacters = function (match) {\n    var good = '';\n    for (var i = 0; i < match.length; i++) {\n      var code = match.charCodeAt(i);\n      // If you're sanitising a path, a slash character is there to be interpreted\n      // by whatever parses the path later as \"escape the next thing\".\n      //\n      // e.g., if you want to index THIS string:\n      //   {\"foo\": {\"bar.baz\": \"THIS\"}}\n      // Your index path would be \"foo.bar\\.baz\".\n\n      if (code === IS_DOT && isPath && i === 0) {\n        good += '.';\n      } else if (code === SLASH && isPath) {\n        continue;\n      } else {\n        good += '_c' + code + '_';\n      }\n    }\n    return good;\n  };\n\n  if (isPath) {\n    return name.replace(PATH_INVALID, correctCharacters);\n  } else {\n    return name.replace(KEY_INVALID, correctCharacters);\n  }\n}\n\nfunction needsRewrite(data) {\n  for (var key of Object.keys(data)) {\n    if (needsSanitise(key)) {\n      return true;\n    } else if (data[key] === null || typeof data[key] === 'boolean') {\n      return true;\n    } else if (typeof data[key] === 'object') {\n      return needsRewrite(data[key]);\n    }\n  }\n}\n\nfunction rewrite(data) {\n  if (!needsRewrite(data)) {\n    return false;\n  }\n\n  var isArray = Array.isArray(data);\n  var clone = isArray\n    ? []\n    : {};\n\n  Object.keys(data).forEach(function (key) {\n    var safeKey = isArray ? key : sanitise(key);\n\n    if (data[key] === null) {\n      clone[safeKey] = IDB_NULL;\n    } else if (typeof data[key] === 'boolean') {\n      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;\n    } else if (typeof data[key] === 'object') {\n      clone[safeKey] = rewrite(data[key]);\n    } else {\n      clone[safeKey] = data[key];\n    }\n  });\n\n  return clone;\n}\n\nvar DOC_STORE = 'docs';\nvar META_STORE = 'meta';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback((0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.IDB_ERROR, message, evt.type));\n  };\n}\n\nfunction processAttachment(name, src, doc, isBinary) {\n\n  delete doc._attachments[name].stub;\n\n  if (isBinary) {\n    doc._attachments[name].data =\n      src.attachments[doc._attachments[name].digest].data;\n    return Promise.resolve();\n  }\n\n  return new Promise(function (resolve) {\n    var data = src.attachments[doc._attachments[name].digest].data;\n    (0,pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__.readAsBinaryString)(data, function (binString) {\n      doc._attachments[name].data = (0,pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__.btoa)(binString);\n      delete doc._attachments[name].length;\n      resolve();\n    });\n  });\n}\n\nfunction rawIndexFields(ddoc, viewName) {\n  // fields are an array of either the string name of the field, or a key value\n  var fields = ddoc.views[viewName].options &&\n               ddoc.views[viewName].options.def &&\n               ddoc.views[viewName].options.def.fields || [];\n\n  // Either ['foo'] or [{'foo': 'desc'}]\n  return fields.map(function (field) {\n    if (typeof field === 'string') {\n      return field;\n    } else {\n      return Object.keys(field)[0];\n    }\n  });\n}\n\nfunction naturalIndexName(fields) {\n  return '_find_idx/' + fields.join('/');\n}\n\n/**\n * Convert the fields the user gave us in the view and convert them to work for\n * indexeddb.\n *\n * fields is an array of field strings. A field string could be one field:\n *   'foo'\n * Or it could be a json path:\n *   'foo.bar'\n */\nfunction correctIndexFields(fields) {\n  // Every index has to have deleted at the front, because when we do a query\n  // we need to filter out deleted documents.\n  return ['deleted'].concat(\n    fields.map(function (field) {\n      if (field in ['_id', '_rev', '_deleted', '_attachments']) {\n        // These properties are stored at the top level without the underscore\n        return field.substr(1);\n      } else {\n        // The custom document fields are inside the `data` property\n        return 'data.' + sanitise(field, true);\n      }\n    })\n  );\n}\n\n//\n// Core PouchDB schema version. Increment this if we, as a library, want to make\n// schema changes in indexeddb. See upgradePouchDbSchema()\n//\nvar POUCHDB_IDB_VERSION = 1;\n\n//\n// Functions that manage a combinate indexeddb version, by combining the current\n// time in millis that represents user migrations with a large multiplier that\n// represents PouchDB system migrations.\n//\n// This lets us use the idb version number to both represent\n// PouchDB-library-level migrations as well as \"user migrations\" required for\n// when design documents trigger the addition or removal of native indexes.\n//\n// Given that Number.MAX_SAFE_INTEGER = 9007199254740991\n//\n// We can easily use the largest 2-3 digits and either allow:\n//  - 900 system migrations up to 2198/02/18\n//  - or 89 system migrations up to 5050/02/14\n//\n// This impl does the former. If this code still exists after 2198 someone send my\n// decendents a Spacebook message congratulating them on their impressive genes.\n//\n// 9007199254740991 <- MAX_SAFE_INTEGER\n//   10000000000000 <- 10^13\n//    7199254740991 <- 2198-02-18T16:59:00.991Z\n//\nvar versionMultiplier = Math.pow(10, 13);\nfunction createIdbVersion() {\n  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();\n}\nfunction getPouchDbVersion(version) {\n  return Math.floor(version / versionMultiplier);\n}\n\nfunction maintainNativeIndexes(openReq, reject) {\n  var docStore = openReq.transaction.objectStore(DOC_STORE);\n  var ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\\uffff'));\n\n  ddocsReq.onsuccess = function (e) {\n    var results = e.target.result;\n    var existingIndexNames = Array.from(docStore.indexNames);\n\n    // NB: the only thing we're supporting here is the declared indexing\n    // fields nothing more.\n    var expectedIndexes = results.filter(function (row) {\n      return row.deleted === 0 && row.revs[row.rev].data.views;\n    }).map(function (row) {\n      return row.revs[row.rev].data;\n    }).reduce(function (indexes, ddoc) {\n      return Object.keys(ddoc.views).reduce(function (acc, viewName) {\n        var fields = rawIndexFields(ddoc, viewName);\n\n        if (fields && fields.length > 0) {\n          acc[naturalIndexName(fields)] = correctIndexFields(fields);\n        }\n\n        return acc;\n      }, indexes);\n    }, {});\n\n    var expectedIndexNames = Object.keys(expectedIndexes);\n\n    // Delete any indexes that aren't system indexes or expected\n    var systemIndexNames = ['seq'];\n    existingIndexNames.forEach(function (index) {\n      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {\n        docStore.deleteIndex(index);\n      }\n    });\n\n    // Work out which indexes are missing and create them\n    var newIndexNames = expectedIndexNames.filter(function (ei) {\n      return existingIndexNames.indexOf(ei) === -1;\n    });\n\n    try {\n      newIndexNames.forEach(function (indexName) {\n        docStore.createIndex(indexName, expectedIndexes[indexName]);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  };\n}\n\nfunction upgradePouchDbSchema(db, pouchdbVersion) {\n  if (pouchdbVersion < 1) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    docStore.createIndex('seq', 'seq', {unique: true});\n\n    db.createObjectStore(META_STORE, {keyPath: 'id'});\n  }\n\n  // Declare more PouchDB schema changes here\n  // if (pouchdbVersion < 2) { .. }\n}\n\nfunction openDatabase(openDatabases, api, opts, resolve, reject) {\n  var openReq = opts.versionchanged ?\n    indexedDB.open(opts.name) :\n    indexedDB.open(opts.name, createIdbVersion());\n\n  openReq.onupgradeneeded = function (e) {\n    if (e.oldVersion > 0 && e.oldVersion < versionMultiplier) {\n      // This DB was created with the \"idb\" adapter, **not** this one.\n      // For now we're going to just error out here: users must manually\n      // migrate between the two. In the future, dependent on performance tests,\n      // we might silently migrate\n      throw new Error('Incorrect adapter: you should specify the \"idb\" adapter to open this DB');\n    } else if (e.oldVersion === 0 && e.newVersion < versionMultiplier) {\n      // Firefox still creates the database with version=1 even if we throw,\n      // so we need to be sure to destroy the empty database before throwing\n      indexedDB.deleteDatabase(opts.name);\n      throw new Error('Database was deleted while open');\n    }\n\n    var db = e.target.result;\n\n    var pouchdbVersion = getPouchDbVersion(e.oldVersion);\n    upgradePouchDbSchema(db, pouchdbVersion);\n    maintainNativeIndexes(openReq, reject);\n  };\n\n  openReq.onblocked = function (e) {\n      // AFAICT this only occurs if, after sending `onversionchange` events to\n      // all other open DBs (ie in different tabs), there are still open\n      // connections to the DB. In this code we should never see this because we\n      // close our DBs on these events, and all DB interactions are wrapped in\n      // safely re-opening the DB.\n      console.error('onblocked, this should never happen', e);\n  };\n\n  openReq.onsuccess = function (e) {\n    var idb = e.target.result;\n\n    idb.onabort = function (e) {\n      console.error('Database has a global failure', e.target.error);\n      delete openDatabases[opts.name];\n      idb.close();\n    };\n\n    idb.onversionchange = function () {\n      console.log('Database was made stale, closing handle');\n      openDatabases[opts.name].versionchanged = true;\n      idb.close();\n    };\n\n    idb.onclose = function () {\n      console.log('Database was made stale, closing handle');\n      if (opts.name in openDatabases) {\n        openDatabases[opts.name].versionchanged = true;\n      }\n    };\n\n    var metadata = {id: META_STORE};\n    var txn = idb.transaction([META_STORE], 'readwrite');\n\n    txn.oncomplete = function () {\n      resolve({idb: idb, metadata: metadata});\n    };\n\n    var metaStore = txn.objectStore(META_STORE);\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metadata = e.target.result || metadata;\n      var changed = false;\n\n      if (!('doc_count' in metadata)) {\n        changed = true;\n        metadata.doc_count = 0;\n      }\n\n      if (!('seq' in metadata)) {\n        changed = true;\n        metadata.seq = 0;\n      }\n\n      if (!('db_uuid' in metadata)) {\n        changed = true;\n        metadata.db_uuid = (0,pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__.uuid)();\n      }\n\n      if (changed) {\n        metaStore.put(metadata);\n      }\n    };\n  };\n\n  openReq.onerror = function (e) {\n    reject(e.target.error);\n  };\n}\n\nfunction setup (openDatabases, api, opts) {\n  if (!openDatabases[opts.name] || openDatabases[opts.name].versionchanged) {\n    opts.versionchanged = openDatabases[opts.name] &&\n                          openDatabases[opts.name].versionchanged;\n\n    openDatabases[opts.name] = new Promise(function (resolve, reject) {\n      openDatabase(openDatabases, api, opts, resolve, reject);\n    });\n  }\n\n  return openDatabases[opts.name];\n}\n\nfunction info (metadata, callback) {\n  callback(null, {\n    doc_count: metadata.doc_count,\n    update_seq: metadata.seq\n  });\n}\n\nfunction get (txn, id, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  txn.txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev;\n    if (!opts.rev) {\n      rev = (doc && doc.rev);\n    } else {\n      rev = opts.latest ? (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.latest)(opts.rev, doc) : opts.rev;\n    }\n\n    if (!doc || (doc.deleted && !opts.rev) || !(rev in doc.revs)) {\n      callback((0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, 'missing'));\n      return;\n    }\n\n    var result = doc.revs[rev].data;\n    result._id = doc.id;\n    result._rev = rev;\n\n    // WARNING: expecting possible old format\n    // TODO: why are we passing the transaction in the context?\n    //       It's not clear we ever thread these txns usefully\n    callback(null, {\n      doc: result,\n      metadata: doc,\n      ctx: txn\n    });\n  };\n}\n\nfunction parseAttachment(attachment, opts, cb) {\n  if (opts.binary) {\n    return cb(null, attachment);\n  } else {\n    (0,pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__.readAsBinaryString)(attachment, function (binString) {\n      cb(null, (0,pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__.btoa)(binString));\n    });\n  }\n}\n\nfunction getAttachment(txn, docId, attachId, _, opts, cb) {\n  if (txn.error) {\n    return cb(txn.error);\n  }\n\n  var attachment;\n\n  txn.txn.objectStore(DOC_STORE).get(docId).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev = doc.revs[opts.rev || doc.rev].data;\n    var digest = rev._attachments[attachId].digest;\n    attachment = doc.attachments[digest].data;\n  };\n\n  txn.txn.oncomplete = function () {\n    parseAttachment(attachment, opts, cb);\n  };\n\n  txn.txn.onabort = cb;\n}\n\nfunction bulkDocs (api, req, opts, metadata, dbOpts, idbChanges, callback) {\n\n  var txn;\n\n  // TODO: I would prefer to get rid of these globals\n  var error;\n  var results = [];\n  var docs = [];\n  var lastWriteIndex;\n\n  var revsLimit = dbOpts.revs_limit || 1000;\n  var rewriteEnabled = dbOpts.name.indexOf(\"-mrview-\") === -1;\n  const autoCompaction = dbOpts.auto_compaction;\n\n  // We only need to track 1 revision for local documents\n  function docsRevsLimit(doc) {\n    return /^_local/.test(doc.id) ? 1 : revsLimit;\n  }\n\n  function rootIsMissing(doc) {\n    return doc.rev_tree[0].ids[1].status === 'missing';\n  }\n\n  function parseBase64(data) {\n    try {\n      return atob(data);\n    } catch (e) {\n      return {\n        error: (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.BAD_ARG, 'Attachment is not a valid base64 string')\n      };\n    }\n  }\n\n  // Reads the original doc from the store if available\n  // As in allDocs with keys option using multiple get calls is the fastest way\n  function fetchExistingDocs(txn, docs) {\n    var fetched = 0;\n    var oldDocs = {};\n\n    function readDone(e) {\n      if (e.target.result) {\n        oldDocs[e.target.result.id] = e.target.result;\n      }\n      if (++fetched === docs.length) {\n        processDocs(txn, docs, oldDocs);\n      }\n    }\n\n    docs.forEach(function (doc) {\n      txn.objectStore(DOC_STORE).get(doc.id).onsuccess = readDone;\n    });\n  }\n\n  function revHasAttachment(doc, rev, digest) {\n    return doc.revs[rev] &&\n      doc.revs[rev].data._attachments &&\n      Object.values(doc.revs[rev].data._attachments).find(function (att) {\n        return att.digest === digest;\n      });\n  }\n\n  function processDocs(txn, docs, oldDocs) {\n\n    docs.forEach(function (doc, i) {\n      var newDoc;\n\n      // The first document write cannot be a deletion\n      if ('was_delete' in opts && !(Object.prototype.hasOwnProperty.call(oldDocs, doc.id))) {\n        newDoc = (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, 'deleted');\n\n      // The first write of a document cannot specify a revision\n      } else if (opts.new_edits &&\n                 !Object.prototype.hasOwnProperty.call(oldDocs, doc.id) &&\n                 rootIsMissing(doc)) {\n        newDoc = (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT);\n\n      // Update the existing document\n      } else if (Object.prototype.hasOwnProperty.call(oldDocs, doc.id)) {\n        newDoc = update(txn, doc, oldDocs[doc.id]);\n        // The update can be rejected if it is an update to an existing\n        // revision, if so skip it\n        if (newDoc == false) {\n          return;\n        }\n\n      // New document\n      } else {\n        // Ensure new documents are also stemmed\n        var merged = (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.merge)([], doc.rev_tree[0], docsRevsLimit(doc));\n        doc.rev_tree = merged.tree;\n        doc.stemmedRevs = merged.stemmedRevs;\n        newDoc = doc;\n        newDoc.isNewDoc = true;\n        newDoc.wasDeleted = doc.revs[doc.rev].deleted ? 1 : 0;\n      }\n\n      if (newDoc.error) {\n        results[i] = newDoc;\n      } else {\n        oldDocs[newDoc.id] = newDoc;\n        lastWriteIndex = i;\n        write(txn, newDoc, i);\n      }\n    });\n  }\n\n  // Converts from the format returned by parseDoc into the new format\n  // we use to store\n  function convertDocFormat(doc) {\n\n    var newDoc = {\n      id: doc.metadata.id,\n      rev: doc.metadata.rev,\n      rev_tree: doc.metadata.rev_tree,\n      revs: doc.metadata.revs || {}\n    };\n\n    newDoc.revs[newDoc.rev] = {\n      data: doc.data,\n      deleted: doc.metadata.deleted\n    };\n\n    return newDoc;\n  }\n\n  function update(txn, doc, oldDoc) {\n\n    // Ignore updates to existing revisions\n    if ((doc.rev in oldDoc.revs) && !opts.new_edits) {\n      return false;\n    }\n\n    var isRoot = /^1-/.test(doc.rev);\n\n    // Reattach first writes after a deletion to last deleted tree\n    if (oldDoc.deleted && !doc.deleted && opts.new_edits && isRoot) {\n      var tmp = doc.revs[doc.rev].data;\n      tmp._rev = oldDoc.rev;\n      tmp._id = oldDoc.id;\n      doc = convertDocFormat((0,pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__.parseDoc)(tmp, opts.new_edits, dbOpts));\n    }\n\n    var merged = (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.merge)(oldDoc.rev_tree, doc.rev_tree[0], docsRevsLimit(doc));\n    doc.stemmedRevs = merged.stemmedRevs;\n    doc.rev_tree = merged.tree;\n\n    // Merge the old and new rev data\n    var revs = oldDoc.revs;\n    revs[doc.rev] = doc.revs[doc.rev];\n    doc.revs = revs;\n\n    doc.attachments = oldDoc.attachments;\n\n    var inConflict = opts.new_edits && (((oldDoc.deleted && doc.deleted) ||\n       (!oldDoc.deleted && merged.conflicts !== 'new_leaf') ||\n       (oldDoc.deleted && !doc.deleted && merged.conflicts === 'new_branch') ||\n       (oldDoc.rev === doc.rev)));\n\n    if (inConflict) {\n      return (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT);\n    }\n\n    doc.wasDeleted = oldDoc.deleted;\n\n    return doc;\n  }\n\n  function write(txn, doc, i) {\n\n    // We copy the data from the winning revision into the root\n    // of the document so that it can be indexed\n    var winningRev$$1 = (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.winningRev)(doc);\n    // rev of new doc for attachments and to return it\n    var writtenRev = doc.rev;\n    var isLocal = /^_local/.test(doc.id);\n\n    var theDoc = doc.revs[winningRev$$1].data;\n\n    const isNewDoc = doc.isNewDoc;\n\n    if (rewriteEnabled) {\n      // doc.data is what we index, so we need to clone and rewrite it, and clean\n      // it up for indexability\n      var result = rewrite(theDoc);\n      if (result) {\n        doc.data = result;\n        delete doc.data._attachments;\n      } else {\n        doc.data = theDoc;\n      }\n    } else {\n      doc.data = theDoc;\n    }\n\n    doc.rev = winningRev$$1;\n    // .deleted needs to be an int for indexing\n    doc.deleted = doc.revs[winningRev$$1].deleted ? 1 : 0;\n\n    // Bump the seq for every new (non local) revision written\n    // TODO: index expects a unique seq, not sure if ignoring local will\n    // work\n    if (!isLocal) {\n      doc.seq = ++metadata.seq;\n\n      var delta = 0;\n      // If its a new document, we wont decrement if deleted\n      if (doc.isNewDoc) {\n        delta = doc.deleted ? 0 : 1;\n      } else if (doc.wasDeleted !== doc.deleted) {\n        delta = doc.deleted ? -1 : 1;\n      }\n      metadata.doc_count += delta;\n    }\n    delete doc.isNewDoc;\n    delete doc.wasDeleted;\n\n    // If there have been revisions stemmed when merging trees,\n    // delete their data\n    let revsToDelete = doc.stemmedRevs || [];\n\n    if (autoCompaction && !isNewDoc) {\n      const result = (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.compactTree)(doc);\n      if (result.length) {\n        revsToDelete = revsToDelete.concat(result);\n      }\n    }\n\n    if (revsToDelete.length) {\n      revsToDelete.forEach(function (rev) { delete doc.revs[rev]; });\n    }\n\n    delete doc.stemmedRevs;\n\n    if (!('attachments' in doc)) {\n      doc.attachments = {};\n    }\n\n    if (theDoc._attachments) {\n      for (var k in theDoc._attachments) {\n        var attachment = theDoc._attachments[k];\n        if (attachment.stub) {\n          if (!(attachment.digest in doc.attachments)) {\n            error = (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_STUB);\n            // TODO: Not sure how safe this manual abort is, seeing\n            // console issues\n            txn.abort();\n            return;\n          }\n\n          if (revHasAttachment(doc, writtenRev, attachment.digest)) {\n            doc.attachments[attachment.digest].revs[writtenRev] = true;\n          }\n\n        } else {\n\n          doc.attachments[attachment.digest] = attachment;\n          doc.attachments[attachment.digest].revs = {};\n          doc.attachments[attachment.digest].revs[writtenRev] = true;\n\n          theDoc._attachments[k] = {\n            stub: true,\n            digest: attachment.digest,\n            content_type: attachment.content_type,\n            length: attachment.length,\n            revpos: parseInt(writtenRev, 10)\n          };\n        }\n      }\n    }\n\n    // Local documents have different revision handling\n    if (isLocal && doc.deleted) {\n      txn.objectStore(DOC_STORE).delete(doc.id).onsuccess = function () {\n        results[i] = {\n          ok: true,\n          id: doc.id,\n          rev: '0-0'\n        };\n      };\n      updateSeq(i);\n      return;\n    }\n\n    txn.objectStore(DOC_STORE).put(doc).onsuccess = function () {\n      results[i] = {\n        ok: true,\n        id: doc.id,\n        rev: writtenRev\n      };\n      updateSeq(i);\n    };\n  }\n\n  function updateSeq(i) {\n    if (i === lastWriteIndex) {\n      txn.objectStore(META_STORE).put(metadata);\n    }\n  }\n\n  function preProcessAttachment(attachment) {\n    if (attachment.stub) {\n      return Promise.resolve(attachment);\n    }\n\n    var binData;\n    if (typeof attachment.data === 'string') {\n      binData = parseBase64(attachment.data);\n      if (binData.error) {\n        return Promise.reject(binData.error);\n      }\n      attachment.data = (0,pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__.binaryStringToBlobOrBuffer)(binData, attachment.content_type);\n    } else {\n      binData = attachment.data;\n    }\n\n    return new Promise(function (resolve) {\n      (0,pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__.binaryMd5)(binData, function (result) {\n        attachment.digest = 'md5-' + result;\n        attachment.length = binData.size || binData.length || 0;\n        resolve(attachment);\n      });\n    });\n  }\n\n  function preProcessAttachments() {\n    var promises = docs.map(function (doc) {\n      var data = doc.revs[doc.rev].data;\n      if (!data._attachments) {\n        return Promise.resolve(data);\n      }\n      var attachments = Object.keys(data._attachments).map(function (k) {\n        data._attachments[k].name = k;\n        return preProcessAttachment(data._attachments[k]);\n      });\n\n      return Promise.all(attachments).then(function (newAttachments) {\n        var processed = {};\n        newAttachments.forEach(function (attachment) {\n          processed[attachment.name] = attachment;\n          delete attachment.name;\n        });\n        data._attachments = processed;\n        return data;\n      });\n    });\n    return Promise.all(promises);\n  }\n\n  for (var i = 0, len = req.docs.length; i < len; i++) {\n    var result;\n    // TODO: We should get rid of throwing for invalid docs, also not sure\n    // why this is needed in idb-next and not idb\n    try {\n      result = (0,pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__.parseDoc)(req.docs[i], opts.new_edits, dbOpts);\n    } catch (err) {\n      result = err;\n    }\n    if (result.error) {\n      return callback(result);\n    }\n\n    // Ideally parseDoc would return data in this format, but it is currently\n    // shared so we need to convert\n    docs.push(convertDocFormat(result));\n  }\n\n  preProcessAttachments().then(function () {\n    api._openTransactionSafely([DOC_STORE, META_STORE], 'readwrite', function (err, _txn) {\n      if (err) {\n        return callback(err);\n      }\n\n      txn = _txn;\n\n      txn.onabort = function () {\n        callback(error || (0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.UNKNOWN_ERROR, 'transaction was aborted'));\n      };\n      txn.ontimeout = idbError(callback);\n\n      txn.oncomplete = function () {\n        idbChanges.notify(dbOpts.name);\n        callback(null, results);\n      };\n\n      // We would like to use promises here, but idb sucks\n      fetchExistingDocs(txn, docs);\n    });\n  }).catch(function (err) {\n    callback(err);\n  });\n}\n\nfunction allDocsKeys(keys, docStore, allDocsInner) {\n  // It's not guaranted to be returned in right order\n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n      valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        valuesBatch.forEach(function (doc) {\n            allDocsInner(doc);\n        });\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(opts, metadata, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n  callback((0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.IDB_ERROR, err.name, err.message));\n}\n\nfunction allDocs (txn, metadata, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  // TODO: Weird hack, I dont like it\n  if (opts.limit === 0) {\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n\n  var results = [];\n  var processing = [];\n\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n  var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n  var keyRange;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(opts, metadata, keyRange.error, callback);\n    }\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  txn.txn.oncomplete = onTxnComplete;\n\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, allDocsInner);\n  }\n\n  function include_doc(row, doc) {\n    var docData = doc.revs[doc.rev].data;\n\n    row.doc = docData;\n    row.doc._id = doc.id;\n    row.doc._rev = doc.rev;\n    if (opts.conflicts) {\n      var conflicts = (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.collectConflicts)(doc);\n      if (conflicts.length) {\n        row.doc._conflicts = conflicts;\n      }\n    }\n    if (opts.attachments && docData._attachments) {\n      for (var name in docData._attachments) {\n        processing.push(processAttachment(name, doc, row.doc, opts.binary));\n      }\n    }\n  }\n\n  function allDocsInner(doc) {\n    if (doc.error && keys) {\n      // key was not found with \"keys\" requests\n      results.push(doc);\n      return true;\n    }\n\n    var row = {\n      id: doc.id,\n      key: doc.id,\n      value: {\n        rev: doc.rev\n      }\n    };\n\n    var deleted = doc.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        include_doc(row, doc);\n      }\n      if (--limit === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      var returnVal = {\n        total_rows: metadata.doc_count,\n        offset: 0,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = metadata.seq;\n      }\n      callback(null, returnVal);\n    });\n  }\n\n  var cursor = descending ?\n    docStore.openCursor(keyRange, descending) :\n    docStore.openCursor(keyRange);\n\n  cursor.onsuccess = function (e) {\n\n    var doc = e.target.result && e.target.result.value;\n\n    // Happens if opts does not have limit,\n    // because cursor will end normally then,\n    // when all docs are retrieved.\n    // Would not be needed, if getAll() optimization was used like in #6059\n    if (!doc) { return; }\n\n    // Skip local docs\n    if (/^_local/.test(doc.id)) {\n      return e.target.result.continue();\n    }\n\n    var continueCursor = allDocsInner(doc);\n    if (continueCursor) {\n      e.target.result.continue();\n    }\n  };\n\n}\n\nfunction changes (txn, idbChanges, api, dbOpts, opts) {\n  if (txn.error) {\n    return opts.complete(txn.error);\n  }\n\n  if (opts.continuous) {\n    var id = dbOpts.name + ':' + (0,pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__.uuid)();\n    idbChanges.addListener(dbOpts.name, id, api, opts);\n    idbChanges.notify(dbOpts.name);\n    return {\n      cancel: function () {\n        idbChanges.removeListener(dbOpts.name, id);\n      }\n    };\n  }\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1;\n  }\n\n  var store = txn.txn.objectStore(DOC_STORE).index('seq');\n\n  var filter = (0,pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__.filterChange)(opts);\n  var received = 0;\n\n  var lastSeq = opts.since || 0;\n  var results = [];\n\n  var processing = [];\n\n  function onReqSuccess(e) {\n    if (!e.target.result) { return; }\n    var cursor = e.target.result;\n    var doc = cursor.value;\n    // Overwrite doc.data, which may have been rewritten (see rewrite.js) with\n    // the clean version for that rev\n    doc.data = doc.revs[doc.rev].data;\n    doc.data._id = doc.id;\n    doc.data._rev = doc.rev;\n    if (doc.deleted) {\n      doc.data._deleted = true;\n    }\n\n    if (opts.doc_ids && opts.doc_ids.indexOf(doc.id) === -1) {\n      return cursor.continue();\n    }\n\n    // WARNING: expecting possible old format\n    var change = opts.processChange(doc.data, doc, opts);\n    change.seq = doc.seq;\n    lastSeq = doc.seq;\n    var filtered = filter(change);\n\n    // If its an error\n    if (typeof filtered === 'object') {\n      return opts.complete(filtered);\n    }\n\n    if (filtered) {\n      received++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n\n      if (opts.include_docs && opts.attachments && doc.data._attachments) {\n        var promises = [];\n        for (var name in doc.data._attachments) {\n          var p = processAttachment(name, doc, change.doc, opts.binary);\n          // We add the processing promise to 2 arrays, one tracks all\n          // the promises needed before we fire onChange, the other\n          // ensure we process all attachments before onComplete\n          promises.push(p);\n          processing.push(p);\n        }\n\n        Promise.all(promises).then(function () {\n          opts.onChange(change);\n        });\n      } else {\n        opts.onChange(change);\n      }\n    }\n    if (received !== limit) {\n      cursor.continue();\n    }\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      opts.complete(null, {\n        results: results,\n        last_seq: lastSeq\n      });\n    });\n  }\n\n  var req;\n  if (opts.descending) {\n    req = store.openCursor(null, 'prev');\n  } else {\n    req = store.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n  }\n\n  txn.txn.oncomplete = onTxnComplete;\n  req.onsuccess = onReqSuccess;\n}\n\nfunction getRevisionTree (txn, id, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var req = txn.txn.objectStore(DOC_STORE).get(id);\n  req.onsuccess = function (e) {\n    if (!e.target.result) {\n      callback((0,pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC));\n    } else {\n      callback(null, e.target.result.rev_tree);\n    }\n  };\n}\n\nfunction doCompaction (txn, id, revs, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  docStore.get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n\n    (0,pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.traverseRevTree)(doc.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (revs.indexOf(rev) !== -1) {\n        opts.status = 'missing';\n      }\n    });\n\n    var attachments = [];\n\n    revs.forEach(function (rev) {\n      if (rev in doc.revs) {\n        // Make a list of attachments that are used by the revisions being\n        // deleted\n        if (doc.revs[rev].data._attachments) {\n          for (var k in doc.revs[rev].data._attachments) {\n            attachments.push(doc.revs[rev].data._attachments[k].digest);\n          }\n        }\n        delete doc.revs[rev];\n      }\n    });\n\n    // Attachments have a list of revisions that are using them, when\n    // that list becomes empty we can delete the attachment.\n    attachments.forEach(function (digest) {\n      revs.forEach(function (rev) {\n        delete doc.attachments[digest].revs[rev];\n      });\n      if (!Object.keys(doc.attachments[digest].revs).length) {\n        delete doc.attachments[digest];\n      }\n    });\n\n    docStore.put(doc);\n  };\n\n  txn.txn.oncomplete = function () {\n    callback();\n  };\n}\n\nfunction destroy (dbOpts, openDatabases, idbChanges, callback) {\n\n  idbChanges.removeAllListeners(dbOpts.name);\n\n  function doDestroy() {\n    var req = indexedDB.deleteDatabase(dbOpts.name);\n    req.onsuccess = function () {\n      delete openDatabases[dbOpts.name];\n      callback(null, {ok: true});\n    };\n  }\n\n  // If the database is open we need to close it\n  if (dbOpts.name in openDatabases) {\n    openDatabases[dbOpts.name].then(function (res) {\n      res.idb.close();\n      doDestroy();\n    });\n  } else {\n    doDestroy();\n  }\n\n}\n\n// Adapted from\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24\n// This could change / improve in the future?\nvar COUCH_COLLATE_LO = null;\nvar COUCH_COLLATE_HI = '\\uffff'; // actually used as {\"\\uffff\": {}}\n\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\n// Importantly, *there is no upper bound possible* in idb. The ideal data\n// structure an infintely deep array:\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\n// because it looks nice and surely that's enough!\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\n\n//\n// TODO: this should be made offical somewhere and used by AllDocs / get /\n// changes etc as well.\n//\nfunction externaliseRecord(idbDoc) {\n  var doc = idbDoc.revs[idbDoc.rev].data;\n  doc._id = idbDoc.id;\n  doc._rev = idbDoc.rev;\n  if (idbDoc.deleted) {\n    doc._deleted = true;\n  }\n\n  return doc;\n}\n\n/**\n * Generates a keyrange based on the opts passed to query\n *\n * The first key is always 0, as that's how we're filtering out deleted entries.\n */\nfunction generateKeyRange(opts) {\n  function defined(obj, k) {\n    return obj[k] !== void 0;\n  }\n\n  // Converts a valid CouchDB key into a valid IndexedDB one\n  function convert(key, exact) {\n    // The first item in every native index is doc.deleted, and we always want\n    // to only search documents that are not deleted.\n    // \"foo\" -> [0, \"foo\"]\n    var filterDeleted = [0].concat(key);\n\n    return filterDeleted.map(function (k) {\n      // null, true and false are not indexable by indexeddb. When we write\n      // these values we convert them to these constants, and so when we\n      // query for them we need to convert the query also.\n      if (k === null && exact) {\n        // for non-exact queries we treat null as a collate property\n        // see `if (!exact)` block below\n        return IDB_NULL;\n      } else if (k === true) {\n        return IDB_TRUE;\n      } else if (k === false) {\n        return IDB_FALSE;\n      }\n\n      if (!exact) {\n        // We get passed CouchDB's collate low and high values, so for non-exact\n        // ranged queries we're going to convert them to our IDB equivalents\n        if (k === COUCH_COLLATE_LO) {\n          return IDB_COLLATE_LO;\n        } else if (Object.prototype.hasOwnProperty.call(k, COUCH_COLLATE_HI)) {\n          return IDB_COLLATE_HI;\n        }\n      }\n\n      return k;\n    });\n  }\n\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\n  // we invert these later for IndexedDB.\n  if (!defined(opts, 'inclusive_end')) {\n    opts.inclusive_end = true;\n  }\n  if (!defined(opts, 'inclusive_start')) {\n    opts.inclusive_start = true;\n  }\n\n  if (opts.descending) {\n    // Flip before generating. We'll check descending again later when performing\n    // an index request\n    var realEndkey = opts.startkey,\n        realInclusiveEnd = opts.inclusive_start;\n\n    opts.startkey = opts.endkey;\n    opts.endkey = realEndkey;\n    opts.inclusive_start = opts.inclusive_end;\n    opts.inclusive_end = realInclusiveEnd;\n  }\n\n  try {\n    if (defined(opts, 'key')) {\n      return IDBKeyRange.only(convert(opts.key, true));\n    }\n\n    if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {\n      return IDBKeyRange.lowerBound(convert(opts.startkey), !opts.inclusive_start);\n    }\n\n    if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\n    }\n\n    if (defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.bound(\n        convert(opts.startkey),    convert(opts.endkey),\n        !opts.inclusive_start, !opts.inclusive_end\n      );\n    }\n\n    return IDBKeyRange.only([0]);\n  } catch (err) {\n    console.error('Could not generate keyRange', err, opts);\n    throw Error('Could not generate key range with ' + JSON.stringify(opts));\n  }\n}\n\nfunction getIndexHandle(pdb, fields, reject) {\n  var indexName = naturalIndexName(fields);\n\n  return new Promise(function (resolve) {\n    pdb._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {\n      if (err) {\n        return idbError(reject)(err);\n      }\n\n      txn.onabort = idbError(reject);\n      txn.ontimeout = idbError(reject);\n\n      var existingIndexNames = Array.from(txn.objectStore(DOC_STORE).indexNames);\n\n      if (existingIndexNames.indexOf(indexName) === -1) {\n        // The index is missing, force a db restart and try again\n        pdb._freshen()\n          .then(function () { return getIndexHandle(pdb, fields, reject); })\n          .then(resolve);\n      } else {\n        resolve(txn.objectStore(DOC_STORE).index(indexName));\n      }\n    });\n  });\n}\n\n// In theory we should return something like the doc example below, but find\n// only needs rows: [{doc: {...}}], so I think we can just not bother for now\n// {\n//   \"offset\" : 0,\n//   \"rows\": [{\n//     \"id\": \"doc3\",\n//     \"key\": \"Lisa Says\",\n//     \"value\": null,\n//     \"doc\": {\n//       \"_id\": \"doc3\",\n//       \"_rev\": \"1-z\",\n//       \"title\": \"Lisa Says\"\n//     }\n//   }],\n//   \"total_rows\" : 4\n// }\nfunction query(idb, signature, opts) {\n  // At this stage, in the current implementation, find has already gone through\n  // and determined if the index already exists from PouchDB's perspective (eg\n  // there is a design doc for it).\n  //\n  // If we find that the index doesn't exist this means we have to close and\n  // re-open the DB to correct indexes before proceeding, at which point the\n  // index should exist.\n\n  var pdb = this;\n\n  // Assumption, there will be only one /, between the design document name\n  // and the view name.\n  var parts = signature.split('/');\n\n  return new Promise(function (resolve, reject) {\n    pdb.get('_design/' + parts[0]).then(function (ddoc) {\n      var fields = rawIndexFields(ddoc, parts[1]);\n      if (!fields) {\n        throw new Error('ddoc ' + ddoc._id +' with view ' + parts[1] +\n          ' does not have map.options.def.fields defined.');\n      }\n\n      var skip = opts.skip;\n      var limit = Number.isInteger(opts.limit) && opts.limit;\n\n      return getIndexHandle(pdb, fields, reject)\n        .then(function (indexHandle) {\n          var keyRange = generateKeyRange(opts);\n          var req = indexHandle.openCursor(keyRange, opts.descending ? 'prev' : 'next');\n\n          var rows = [];\n          req.onerror = idbError(reject);\n          req.onsuccess = function (e) {\n            var cursor = e.target.result;\n\n            if (!cursor || limit === 0) {\n              return resolve({\n                rows: rows\n              });\n            }\n\n            if (skip) {\n              cursor.advance(skip);\n              skip = false;\n              return;\n            }\n\n            if (limit) {\n              limit = limit - 1;\n            }\n\n            rows.push({doc: externaliseRecord(cursor.value)});\n            cursor.continue();\n          };\n        });\n      })\n      .catch(reject);\n  });\n\n}\n\nfunction viewCleanup() {\n  // I'm not sure we have to do anything here.\n  //\n  // One option is to just close and re-open the DB, which performs the same\n  // action. The only reason you'd want to call this is if you deleted a bunch\n  // of indexes and wanted the space back immediately.\n  //\n  // Otherwise index cleanup happens when:\n  //  - A DB is opened\n  //  - A find query is performed against an index that doesn't exist but should\n\n  return Promise.resolve();\n}\n\nvar ADAPTER_NAME = 'indexeddb';\n\n// TODO: Constructor should be capitalised\nvar idbChanges = new pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__.changesHandler();\n\n// A shared list of database handles\nvar openDatabases = {};\n\nfunction IdbPouch(dbOpts, callback) {\n\n  if (dbOpts.view_adapter) {\n    console.log('Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter');\n  }\n  \n  var api = this;\n  var metadata = {};\n\n  // Wrapper that gives you an active DB handle. You probably want $t.\n  var $ = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n        fun.apply(api, args);\n      }).catch(function (err) {\n        var last = args.pop();\n        if (typeof last === 'function') {\n          last(err);\n        } else {\n          console.error(err);\n        }\n      });\n    };\n  };\n  // the promise version of $\n  var $p = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n\n      return setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n\n        return fun.apply(api, args);\n      });\n    };\n  };\n  // Wrapper that gives you a safe transaction handle. It's important to use\n  // this instead of opening your own transaction from a db handle got from $,\n  // because in the time between getting the db handle and opening the\n  // transaction it may have been invalidated by index changes.\n  var $t = function (fun, stores, mode) {\n    stores = stores || [DOC_STORE];\n    mode = mode || 'readonly';\n\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      var txn = {};\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        txn.txn = res.idb.transaction(stores, mode);\n      }).catch(function (err) {\n        console.error('Failed to establish transaction safely');\n        console.error(err);\n        txn.error = err;\n      }).then(function () {\n        args.unshift(txn);\n        fun.apply(api, args);\n      });\n    };\n  };\n\n  api._openTransactionSafely = function (stores, mode, callback) {\n    $t(function (txn, callback) {\n      callback(txn.error, txn.txn);\n    }, stores, mode)(callback);\n  };\n\n  api._remote = false;\n  api.type = function () { return ADAPTER_NAME; };\n\n  api._id = $(function (_, cb) {\n    cb(null, metadata.db_uuid);\n  });\n\n  api._info = $(function (_, cb) {\n    return info(metadata, cb);\n  });\n\n  api._get = $t(get);\n\n  api._bulkDocs = $(function (_, req, opts, callback) {\n    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);\n  });\n\n  api._allDocs = $t(function (txn, opts, cb) {\n    allDocs(txn, metadata, opts, cb);\n  });\n\n  api._getAttachment = $t(getAttachment);\n\n  api._changes = $t(function (txn, opts) {\n    changes(txn, idbChanges, api, dbOpts, opts);\n  });\n\n  api._getRevisionTree = $t(getRevisionTree);\n  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');\n\n  api._customFindAbstractMapper = {\n    query: $p(query),\n    viewCleanup: $p(viewCleanup)\n  };\n\n  api._destroy = function (opts, callback) {\n    return destroy(dbOpts, openDatabases, idbChanges, callback);\n  };\n\n  api._close = $(function (db, cb) {\n    delete openDatabases[dbOpts.name];\n    db.close();\n    cb();\n  });\n\n  // Closing and re-opening the DB re-generates native indexes\n  api._freshen = function () {\n    return new Promise(function (resolve) {\n      api._close(function () {\n        $(resolve)();\n      });\n    });\n  };\n\n  // TODO: this setTimeout seems nasty, if its needed lets\n  // figure out / explain why\n  setTimeout(function () {\n    callback(null, api);\n  });\n}\n\n// TODO: this isnt really valid permanently, just being lazy to start\nIdbPouch.valid = function () {\n  return true;\n};\n\nfunction index (PouchDB) {\n  PouchDB.adapter(ADAPTER_NAME, IdbPouch, true);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3BvdWNoZGItYWRhcHRlci1pbmRleGVkZGIvbGliL2luZGV4LmVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRGO0FBQzNDO0FBQ1Q7QUFDMkI7QUFDc0Q7QUFDZjs7QUFFMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkRBQVcsQ0FBQyxxREFBUztBQUNsQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksd0VBQWtCO0FBQ3RCLG9DQUFvQywwREFBSTtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUssSUFBSTs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkUsd0NBQXdDLGFBQWE7O0FBRXJELHNDQUFzQyxjQUFjO0FBQ3BEOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQUk7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIscURBQU07QUFDaEM7O0FBRUE7QUFDQSxlQUFlLDJEQUFXLENBQUMsdURBQVc7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSx3RUFBa0I7QUFDdEIsZUFBZSwwREFBSTtBQUNuQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsMkRBQVcsQ0FBQyxtREFBTztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVcsQ0FBQyx1REFBVzs7QUFFeEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlCQUFpQiwyREFBVyxDQUFDLHdEQUFZOztBQUV6QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQkFBcUIsb0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQVE7QUFDckM7O0FBRUEsaUJBQWlCLG9EQUFLO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDJEQUFXLENBQUMsd0RBQVk7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFVO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQVcsQ0FBQyx3REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdGQUEwQjtBQUNsRCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE1BQU0sc0RBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBUTtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLDJEQUFXLENBQUMseURBQWE7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFXLENBQUMscURBQVM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLG1EQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSwyREFBWTtBQUMzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLE9BQU87QUFDakI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsT0FBTztBQUNmLFFBQVEsT0FBTztBQUNmO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrLXZ1ZTovLy8uLi9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWluZGV4ZWRkYi9saWIvaW5kZXguZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnRvYSwgcmVhZEFzQmluYXJ5U3RyaW5nLCBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlciB9IGZyb20gJ3BvdWNoZGItYmluYXJ5LXV0aWxzJztcbmltcG9ydCB7IHBhcnNlRG9jIH0gZnJvbSAncG91Y2hkYi1hZGFwdGVyLXV0aWxzJztcbmltcG9ydCB7IGJpbmFyeU1kNSB9IGZyb20gJ3BvdWNoZGItbWQ1JztcbmltcG9ydCB7IHV1aWQsIGZpbHRlckNoYW5nZSwgY2hhbmdlc0hhbmRsZXIgfSBmcm9tICdwb3VjaGRiLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUVycm9yLCBJREJfRVJST1IsIE1JU1NJTkdfRE9DLCBSRVZfQ09ORkxJQ1QsIE1JU1NJTkdfU1RVQiwgQkFEX0FSRywgVU5LTk9XTl9FUlJPUiB9IGZyb20gJ3BvdWNoZGItZXJyb3JzJztcbmltcG9ydCB7IGxhdGVzdCwgd2lubmluZ1JldiwgbWVyZ2UsIGNvbXBhY3RUcmVlLCBjb2xsZWN0Q29uZmxpY3RzLCB0cmF2ZXJzZVJldlRyZWUgfSBmcm9tICdwb3VjaGRiLW1lcmdlJztcblxudmFyIElEQl9OVUxMID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG52YXIgSURCX0ZBTFNFID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyAxO1xudmFyIElEQl9UUlVFID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyAyO1xuXG4vLyBUaGVzZSBhcmUgdGhlIHNhbWUgYXMgYmVsbG93IGJ1dCB3aXRob3V0IHRoZSBnbG9iYWwgZmxhZ1xuLy8gd2Ugd2FudCB0byB1c2UgUmVnRXhwLnRlc3QgYmVjYXVzZSBpdCdzIHJlYWxseSBmYXN0LCBidXQgdGhlIGdsb2JhbCBmbGFnXG4vLyBtYWtlcyB0aGUgcmVnZXggY29uc3Qgc3RhdGVmdWwgKHNlcmlvdXNseSkgYXMgaXQgd2Fsa2VkIHRocm91Z2ggYWxsIGluc3RhbmNlc1xudmFyIFRFU1RfS0VZX0lOVkFMSUQgPSAvXlteYS16QS1aXyRdfFteYS16QS1aMC05XyRdKy87XG52YXIgVEVTVF9QQVRIX0lOVkFMSUQgPSAvXFxcXC58KF58XFwuKVteYS16QS1aXyRdfFteYS16QS1aMC05XyQuXSsvO1xuZnVuY3Rpb24gbmVlZHNTYW5pdGlzZShuYW1lLCBpc1BhdGgpIHtcbiAgaWYgKGlzUGF0aCkge1xuICAgIHJldHVybiBURVNUX1BBVEhfSU5WQUxJRC50ZXN0KG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBURVNUX0tFWV9JTlZBTElELnRlc3QobmFtZSk7XG4gIH1cbn1cblxuLy9cbi8vIEluZGV4ZWREQiBvbmx5IGFsbG93cyB2YWxpZCBKUyBuYW1lcyBpbiBpdHMgaW5kZXggcGF0aHMsIHdoZXJlYXMgSlNPTiBhbGxvd3Ncbi8vIGZvciBhbnkgc3RyaW5nIGF0IGFsbC4gVGhpcyBjb252ZXJ0cyBpbnZhbGlkIEpTIG5hbWVzIHRvIHZhbGlkIG9uZXMsIHRvIGFsbG93XG4vLyBmb3IgdGhlbSB0byBiZSBpbmRleGVkLlxuLy9cbi8vIEZvciBleGFtcGxlLCBcImZvby1iYXJcIiBpcyBhIHZhbGlkIEpTT04ga2V5LCBidXQgY2Fubm90IGJlIGEgdmFsaWQgSlMgbmFtZVxuLy8gKGJlY2F1c2UgdGhhdCB3b3VsZCBiZSByZWFkIGFzIGZvbyBtaW51cyBiYXIpLlxuLy9cbi8vIFZlcnkgaGlnaCBsZXZlbCBydWxlcyBmb3IgdmFsaWQgSlMgbmFtZXMgYXJlOlxuLy8gIC0gRmlyc3QgY2hhcmFjdGVyIGNhbm5vdCBzdGFydCB3aXRoIGEgbnVtYmVyXG4vLyAgLSBPdGhlcndpc2UgYWxsIGNoYXJhY3RlcnMgbXVzdCBiZSBiZSBhLXosIEEtWiwgMC05LCAkIG9yIF8uXG4vLyAgLSBXZSBhbGxvdyAuIHVubGVzcyB0aGUgbmFtZSByZXByZXNlbnRzIGEgc2luZ2xlIGZpZWxkLCBhcyB0aGF0IHJlcHJlc2VudHNcbi8vICAgIGEgZGVlcCBpbmRleCBwYXRoLlxuLy9cbi8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaXQgbmVlZHMgdG8gYmUsIGJ1dCBhbHNvIHNpbXBsZXIuXG4vL1xudmFyIEtFWV9JTlZBTElEID0gbmV3IFJlZ0V4cChURVNUX0tFWV9JTlZBTElELnNvdXJjZSwgJ2cnKTtcbnZhciBQQVRIX0lOVkFMSUQgPSBuZXcgUmVnRXhwKFRFU1RfUEFUSF9JTlZBTElELnNvdXJjZSwgJ2cnKTtcbnZhciBTTEFTSCA9ICdcXFxcJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgSVNfRE9UID0gJy4nLmNoYXJDb2RlQXQoMCk7XG5cbmZ1bmN0aW9uIHNhbml0aXNlKG5hbWUsIGlzUGF0aCkge1xuICB2YXIgY29ycmVjdENoYXJhY3RlcnMgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICB2YXIgZ29vZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2RlID0gbWF0Y2guY2hhckNvZGVBdChpKTtcbiAgICAgIC8vIElmIHlvdSdyZSBzYW5pdGlzaW5nIGEgcGF0aCwgYSBzbGFzaCBjaGFyYWN0ZXIgaXMgdGhlcmUgdG8gYmUgaW50ZXJwcmV0ZWRcbiAgICAgIC8vIGJ5IHdoYXRldmVyIHBhcnNlcyB0aGUgcGF0aCBsYXRlciBhcyBcImVzY2FwZSB0aGUgbmV4dCB0aGluZ1wiLlxuICAgICAgLy9cbiAgICAgIC8vIGUuZy4sIGlmIHlvdSB3YW50IHRvIGluZGV4IFRISVMgc3RyaW5nOlxuICAgICAgLy8gICB7XCJmb29cIjoge1wiYmFyLmJhelwiOiBcIlRISVNcIn19XG4gICAgICAvLyBZb3VyIGluZGV4IHBhdGggd291bGQgYmUgXCJmb28uYmFyXFwuYmF6XCIuXG5cbiAgICAgIGlmIChjb2RlID09PSBJU19ET1QgJiYgaXNQYXRoICYmIGkgPT09IDApIHtcbiAgICAgICAgZ29vZCArPSAnLic7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IFNMQVNIICYmIGlzUGF0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvb2QgKz0gJ19jJyArIGNvZGUgKyAnXyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnb29kO1xuICB9O1xuXG4gIGlmIChpc1BhdGgpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKFBBVEhfSU5WQUxJRCwgY29ycmVjdENoYXJhY3RlcnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoS0VZX0lOVkFMSUQsIGNvcnJlY3RDaGFyYWN0ZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1Jld3JpdGUoZGF0YSkge1xuICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMoZGF0YSkpIHtcbiAgICBpZiAobmVlZHNTYW5pdGlzZShrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGFba2V5XSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YVtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1Jld3JpdGUoZGF0YVtrZXldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV3cml0ZShkYXRhKSB7XG4gIGlmICghbmVlZHNSZXdyaXRlKGRhdGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICB2YXIgY2xvbmUgPSBpc0FycmF5XG4gICAgPyBbXVxuICAgIDoge307XG5cbiAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNhZmVLZXkgPSBpc0FycmF5ID8ga2V5IDogc2FuaXRpc2Uoa2V5KTtcblxuICAgIGlmIChkYXRhW2tleV0gPT09IG51bGwpIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gSURCX05VTEw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gZGF0YVtrZXldID8gSURCX1RSVUUgOiBJREJfRkFMU0U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgY2xvbmVbc2FmZUtleV0gPSByZXdyaXRlKGRhdGFba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNsb25lO1xufVxuXG52YXIgRE9DX1NUT1JFID0gJ2RvY3MnO1xudmFyIE1FVEFfU1RPUkUgPSAnbWV0YSc7XG5cbmZ1bmN0aW9uIGlkYkVycm9yKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAndW5rbm93bl9lcnJvcic7XG4gICAgaWYgKGV2dC50YXJnZXQgJiYgZXZ0LnRhcmdldC5lcnJvcikge1xuICAgICAgbWVzc2FnZSA9IGV2dC50YXJnZXQuZXJyb3IubmFtZSB8fCBldnQudGFyZ2V0LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKElEQl9FUlJPUiwgbWVzc2FnZSwgZXZ0LnR5cGUpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dGFjaG1lbnQobmFtZSwgc3JjLCBkb2MsIGlzQmluYXJ5KSB7XG5cbiAgZGVsZXRlIGRvYy5fYXR0YWNobWVudHNbbmFtZV0uc3R1YjtcblxuICBpZiAoaXNCaW5hcnkpIHtcbiAgICBkb2MuX2F0dGFjaG1lbnRzW25hbWVdLmRhdGEgPVxuICAgICAgc3JjLmF0dGFjaG1lbnRzW2RvYy5fYXR0YWNobWVudHNbbmFtZV0uZGlnZXN0XS5kYXRhO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHZhciBkYXRhID0gc3JjLmF0dGFjaG1lbnRzW2RvYy5fYXR0YWNobWVudHNbbmFtZV0uZGlnZXN0XS5kYXRhO1xuICAgIHJlYWRBc0JpbmFyeVN0cmluZyhkYXRhLCBmdW5jdGlvbiAoYmluU3RyaW5nKSB7XG4gICAgICBkb2MuX2F0dGFjaG1lbnRzW25hbWVdLmRhdGEgPSBidG9hKGJpblN0cmluZyk7XG4gICAgICBkZWxldGUgZG9jLl9hdHRhY2htZW50c1tuYW1lXS5sZW5ndGg7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByYXdJbmRleEZpZWxkcyhkZG9jLCB2aWV3TmFtZSkge1xuICAvLyBmaWVsZHMgYXJlIGFuIGFycmF5IG9mIGVpdGhlciB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIGZpZWxkLCBvciBhIGtleSB2YWx1ZVxuICB2YXIgZmllbGRzID0gZGRvYy52aWV3c1t2aWV3TmFtZV0ub3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgZGRvYy52aWV3c1t2aWV3TmFtZV0ub3B0aW9ucy5kZWYgJiZcbiAgICAgICAgICAgICAgIGRkb2Mudmlld3Nbdmlld05hbWVdLm9wdGlvbnMuZGVmLmZpZWxkcyB8fCBbXTtcblxuICAvLyBFaXRoZXIgWydmb28nXSBvciBbeydmb28nOiAnZGVzYyd9XVxuICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZmllbGQpWzBdO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5hdHVyYWxJbmRleE5hbWUoZmllbGRzKSB7XG4gIHJldHVybiAnX2ZpbmRfaWR4LycgKyBmaWVsZHMuam9pbignLycpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGZpZWxkcyB0aGUgdXNlciBnYXZlIHVzIGluIHRoZSB2aWV3IGFuZCBjb252ZXJ0IHRoZW0gdG8gd29yayBmb3JcbiAqIGluZGV4ZWRkYi5cbiAqXG4gKiBmaWVsZHMgaXMgYW4gYXJyYXkgb2YgZmllbGQgc3RyaW5ncy4gQSBmaWVsZCBzdHJpbmcgY291bGQgYmUgb25lIGZpZWxkOlxuICogICAnZm9vJ1xuICogT3IgaXQgY291bGQgYmUgYSBqc29uIHBhdGg6XG4gKiAgICdmb28uYmFyJ1xuICovXG5mdW5jdGlvbiBjb3JyZWN0SW5kZXhGaWVsZHMoZmllbGRzKSB7XG4gIC8vIEV2ZXJ5IGluZGV4IGhhcyB0byBoYXZlIGRlbGV0ZWQgYXQgdGhlIGZyb250LCBiZWNhdXNlIHdoZW4gd2UgZG8gYSBxdWVyeVxuICAvLyB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgZGVsZXRlZCBkb2N1bWVudHMuXG4gIHJldHVybiBbJ2RlbGV0ZWQnXS5jb25jYXQoXG4gICAgZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCBpbiBbJ19pZCcsICdfcmV2JywgJ19kZWxldGVkJywgJ19hdHRhY2htZW50cyddKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBhdCB0aGUgdG9wIGxldmVsIHdpdGhvdXQgdGhlIHVuZGVyc2NvcmVcbiAgICAgICAgcmV0dXJuIGZpZWxkLnN1YnN0cigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjdXN0b20gZG9jdW1lbnQgZmllbGRzIGFyZSBpbnNpZGUgdGhlIGBkYXRhYCBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gJ2RhdGEuJyArIHNhbml0aXNlKGZpZWxkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vL1xuLy8gQ29yZSBQb3VjaERCIHNjaGVtYSB2ZXJzaW9uLiBJbmNyZW1lbnQgdGhpcyBpZiB3ZSwgYXMgYSBsaWJyYXJ5LCB3YW50IHRvIG1ha2Vcbi8vIHNjaGVtYSBjaGFuZ2VzIGluIGluZGV4ZWRkYi4gU2VlIHVwZ3JhZGVQb3VjaERiU2NoZW1hKClcbi8vXG52YXIgUE9VQ0hEQl9JREJfVkVSU0lPTiA9IDE7XG5cbi8vXG4vLyBGdW5jdGlvbnMgdGhhdCBtYW5hZ2UgYSBjb21iaW5hdGUgaW5kZXhlZGRiIHZlcnNpb24sIGJ5IGNvbWJpbmluZyB0aGUgY3VycmVudFxuLy8gdGltZSBpbiBtaWxsaXMgdGhhdCByZXByZXNlbnRzIHVzZXIgbWlncmF0aW9ucyB3aXRoIGEgbGFyZ2UgbXVsdGlwbGllciB0aGF0XG4vLyByZXByZXNlbnRzIFBvdWNoREIgc3lzdGVtIG1pZ3JhdGlvbnMuXG4vL1xuLy8gVGhpcyBsZXRzIHVzIHVzZSB0aGUgaWRiIHZlcnNpb24gbnVtYmVyIHRvIGJvdGggcmVwcmVzZW50XG4vLyBQb3VjaERCLWxpYnJhcnktbGV2ZWwgbWlncmF0aW9ucyBhcyB3ZWxsIGFzIFwidXNlciBtaWdyYXRpb25zXCIgcmVxdWlyZWQgZm9yXG4vLyB3aGVuIGRlc2lnbiBkb2N1bWVudHMgdHJpZ2dlciB0aGUgYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBuYXRpdmUgaW5kZXhlcy5cbi8vXG4vLyBHaXZlbiB0aGF0IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MVxuLy9cbi8vIFdlIGNhbiBlYXNpbHkgdXNlIHRoZSBsYXJnZXN0IDItMyBkaWdpdHMgYW5kIGVpdGhlciBhbGxvdzpcbi8vICAtIDkwMCBzeXN0ZW0gbWlncmF0aW9ucyB1cCB0byAyMTk4LzAyLzE4XG4vLyAgLSBvciA4OSBzeXN0ZW0gbWlncmF0aW9ucyB1cCB0byA1MDUwLzAyLzE0XG4vL1xuLy8gVGhpcyBpbXBsIGRvZXMgdGhlIGZvcm1lci4gSWYgdGhpcyBjb2RlIHN0aWxsIGV4aXN0cyBhZnRlciAyMTk4IHNvbWVvbmUgc2VuZCBteVxuLy8gZGVjZW5kZW50cyBhIFNwYWNlYm9vayBtZXNzYWdlIGNvbmdyYXR1bGF0aW5nIHRoZW0gb24gdGhlaXIgaW1wcmVzc2l2ZSBnZW5lcy5cbi8vXG4vLyA5MDA3MTk5MjU0NzQwOTkxIDwtIE1BWF9TQUZFX0lOVEVHRVJcbi8vICAgMTAwMDAwMDAwMDAwMDAgPC0gMTBeMTNcbi8vICAgIDcxOTkyNTQ3NDA5OTEgPC0gMjE5OC0wMi0xOFQxNjo1OTowMC45OTFaXG4vL1xudmFyIHZlcnNpb25NdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIDEzKTtcbmZ1bmN0aW9uIGNyZWF0ZUlkYlZlcnNpb24oKSB7XG4gIHJldHVybiAodmVyc2lvbk11bHRpcGxpZXIgKiBQT1VDSERCX0lEQl9WRVJTSU9OKSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZ2V0UG91Y2hEYlZlcnNpb24odmVyc2lvbikge1xuICByZXR1cm4gTWF0aC5mbG9vcih2ZXJzaW9uIC8gdmVyc2lvbk11bHRpcGxpZXIpO1xufVxuXG5mdW5jdGlvbiBtYWludGFpbk5hdGl2ZUluZGV4ZXMob3BlblJlcSwgcmVqZWN0KSB7XG4gIHZhciBkb2NTdG9yZSA9IG9wZW5SZXEudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcbiAgdmFyIGRkb2NzUmVxID0gZG9jU3RvcmUuZ2V0QWxsKElEQktleVJhbmdlLmJvdW5kKCdfZGVzaWduLycsICdfZGVzaWduL1xcdWZmZmYnKSk7XG5cbiAgZGRvY3NSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcmVzdWx0cyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgZXhpc3RpbmdJbmRleE5hbWVzID0gQXJyYXkuZnJvbShkb2NTdG9yZS5pbmRleE5hbWVzKTtcblxuICAgIC8vIE5COiB0aGUgb25seSB0aGluZyB3ZSdyZSBzdXBwb3J0aW5nIGhlcmUgaXMgdGhlIGRlY2xhcmVkIGluZGV4aW5nXG4gICAgLy8gZmllbGRzIG5vdGhpbmcgbW9yZS5cbiAgICB2YXIgZXhwZWN0ZWRJbmRleGVzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5kZWxldGVkID09PSAwICYmIHJvdy5yZXZzW3Jvdy5yZXZdLmRhdGEudmlld3M7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiByb3cucmV2c1tyb3cucmV2XS5kYXRhO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoaW5kZXhlcywgZGRvYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRkb2Mudmlld3MpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2aWV3TmFtZSkge1xuICAgICAgICB2YXIgZmllbGRzID0gcmF3SW5kZXhGaWVsZHMoZGRvYywgdmlld05hbWUpO1xuXG4gICAgICAgIGlmIChmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhY2NbbmF0dXJhbEluZGV4TmFtZShmaWVsZHMpXSA9IGNvcnJlY3RJbmRleEZpZWxkcyhmaWVsZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIGluZGV4ZXMpO1xuICAgIH0sIHt9KTtcblxuICAgIHZhciBleHBlY3RlZEluZGV4TmFtZXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZEluZGV4ZXMpO1xuXG4gICAgLy8gRGVsZXRlIGFueSBpbmRleGVzIHRoYXQgYXJlbid0IHN5c3RlbSBpbmRleGVzIG9yIGV4cGVjdGVkXG4gICAgdmFyIHN5c3RlbUluZGV4TmFtZXMgPSBbJ3NlcSddO1xuICAgIGV4aXN0aW5nSW5kZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKHN5c3RlbUluZGV4TmFtZXMuaW5kZXhPZihpbmRleCkgPT09IC0xICAmJiBleHBlY3RlZEluZGV4TmFtZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGRvY1N0b3JlLmRlbGV0ZUluZGV4KGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdvcmsgb3V0IHdoaWNoIGluZGV4ZXMgYXJlIG1pc3NpbmcgYW5kIGNyZWF0ZSB0aGVtXG4gICAgdmFyIG5ld0luZGV4TmFtZXMgPSBleHBlY3RlZEluZGV4TmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChlaSkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nSW5kZXhOYW1lcy5pbmRleE9mKGVpKSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgbmV3SW5kZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcbiAgICAgICAgZG9jU3RvcmUuY3JlYXRlSW5kZXgoaW5kZXhOYW1lLCBleHBlY3RlZEluZGV4ZXNbaW5kZXhOYW1lXSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZVBvdWNoRGJTY2hlbWEoZGIsIHBvdWNoZGJWZXJzaW9uKSB7XG4gIGlmIChwb3VjaGRiVmVyc2lvbiA8IDEpIHtcbiAgICB2YXIgZG9jU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShET0NfU1RPUkUsIHtrZXlQYXRoIDogJ2lkJ30pO1xuICAgIGRvY1N0b3JlLmNyZWF0ZUluZGV4KCdzZXEnLCAnc2VxJywge3VuaXF1ZTogdHJ1ZX0pO1xuXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoTUVUQV9TVE9SRSwge2tleVBhdGg6ICdpZCd9KTtcbiAgfVxuXG4gIC8vIERlY2xhcmUgbW9yZSBQb3VjaERCIHNjaGVtYSBjaGFuZ2VzIGhlcmVcbiAgLy8gaWYgKHBvdWNoZGJWZXJzaW9uIDwgMikgeyAuLiB9XG59XG5cbmZ1bmN0aW9uIG9wZW5EYXRhYmFzZShvcGVuRGF0YWJhc2VzLCBhcGksIG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgb3BlblJlcSA9IG9wdHMudmVyc2lvbmNoYW5nZWQgP1xuICAgIGluZGV4ZWREQi5vcGVuKG9wdHMubmFtZSkgOlxuICAgIGluZGV4ZWREQi5vcGVuKG9wdHMubmFtZSwgY3JlYXRlSWRiVmVyc2lvbigpKTtcblxuICBvcGVuUmVxLm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUub2xkVmVyc2lvbiA+IDAgJiYgZS5vbGRWZXJzaW9uIDwgdmVyc2lvbk11bHRpcGxpZXIpIHtcbiAgICAgIC8vIFRoaXMgREIgd2FzIGNyZWF0ZWQgd2l0aCB0aGUgXCJpZGJcIiBhZGFwdGVyLCAqKm5vdCoqIHRoaXMgb25lLlxuICAgICAgLy8gRm9yIG5vdyB3ZSdyZSBnb2luZyB0byBqdXN0IGVycm9yIG91dCBoZXJlOiB1c2VycyBtdXN0IG1hbnVhbGx5XG4gICAgICAvLyBtaWdyYXRlIGJldHdlZW4gdGhlIHR3by4gSW4gdGhlIGZ1dHVyZSwgZGVwZW5kZW50IG9uIHBlcmZvcm1hbmNlIHRlc3RzLFxuICAgICAgLy8gd2UgbWlnaHQgc2lsZW50bHkgbWlncmF0ZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYWRhcHRlcjogeW91IHNob3VsZCBzcGVjaWZ5IHRoZSBcImlkYlwiIGFkYXB0ZXIgdG8gb3BlbiB0aGlzIERCJyk7XG4gICAgfSBlbHNlIGlmIChlLm9sZFZlcnNpb24gPT09IDAgJiYgZS5uZXdWZXJzaW9uIDwgdmVyc2lvbk11bHRpcGxpZXIpIHtcbiAgICAgIC8vIEZpcmVmb3ggc3RpbGwgY3JlYXRlcyB0aGUgZGF0YWJhc2Ugd2l0aCB2ZXJzaW9uPTEgZXZlbiBpZiB3ZSB0aHJvdyxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYmUgc3VyZSB0byBkZXN0cm95IHRoZSBlbXB0eSBkYXRhYmFzZSBiZWZvcmUgdGhyb3dpbmdcbiAgICAgIGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShvcHRzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSB3YXMgZGVsZXRlZCB3aGlsZSBvcGVuJyk7XG4gICAgfVxuXG4gICAgdmFyIGRiID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgdmFyIHBvdWNoZGJWZXJzaW9uID0gZ2V0UG91Y2hEYlZlcnNpb24oZS5vbGRWZXJzaW9uKTtcbiAgICB1cGdyYWRlUG91Y2hEYlNjaGVtYShkYiwgcG91Y2hkYlZlcnNpb24pO1xuICAgIG1haW50YWluTmF0aXZlSW5kZXhlcyhvcGVuUmVxLCByZWplY3QpO1xuICB9O1xuXG4gIG9wZW5SZXEub25ibG9ja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIEFGQUlDVCB0aGlzIG9ubHkgb2NjdXJzIGlmLCBhZnRlciBzZW5kaW5nIGBvbnZlcnNpb25jaGFuZ2VgIGV2ZW50cyB0b1xuICAgICAgLy8gYWxsIG90aGVyIG9wZW4gREJzIChpZSBpbiBkaWZmZXJlbnQgdGFicyksIHRoZXJlIGFyZSBzdGlsbCBvcGVuXG4gICAgICAvLyBjb25uZWN0aW9ucyB0byB0aGUgREIuIEluIHRoaXMgY29kZSB3ZSBzaG91bGQgbmV2ZXIgc2VlIHRoaXMgYmVjYXVzZSB3ZVxuICAgICAgLy8gY2xvc2Ugb3VyIERCcyBvbiB0aGVzZSBldmVudHMsIGFuZCBhbGwgREIgaW50ZXJhY3Rpb25zIGFyZSB3cmFwcGVkIGluXG4gICAgICAvLyBzYWZlbHkgcmUtb3BlbmluZyB0aGUgREIuXG4gICAgICBjb25zb2xlLmVycm9yKCdvbmJsb2NrZWQsIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbicsIGUpO1xuICB9O1xuXG4gIG9wZW5SZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaWRiID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgaWRiLm9uYWJvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRGF0YWJhc2UgaGFzIGEgZ2xvYmFsIGZhaWx1cmUnLCBlLnRhcmdldC5lcnJvcik7XG4gICAgICBkZWxldGUgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdO1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGlkYi5vbnZlcnNpb25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YWJhc2Ugd2FzIG1hZGUgc3RhbGUsIGNsb3NpbmcgaGFuZGxlJyk7XG4gICAgICBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0udmVyc2lvbmNoYW5nZWQgPSB0cnVlO1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGlkYi5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc29sZS5sb2coJ0RhdGFiYXNlIHdhcyBtYWRlIHN0YWxlLCBjbG9zaW5nIGhhbmRsZScpO1xuICAgICAgaWYgKG9wdHMubmFtZSBpbiBvcGVuRGF0YWJhc2VzKSB7XG4gICAgICAgIG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXS52ZXJzaW9uY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtZXRhZGF0YSA9IHtpZDogTUVUQV9TVE9SRX07XG4gICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihbTUVUQV9TVE9SRV0sICdyZWFkd3JpdGUnKTtcblxuICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZSh7aWRiOiBpZGIsIG1ldGFkYXRhOiBtZXRhZGF0YX0pO1xuICAgIH07XG5cbiAgICB2YXIgbWV0YVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKE1FVEFfU1RPUkUpO1xuICAgIG1ldGFTdG9yZS5nZXQoTUVUQV9TVE9SRSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1ldGFkYXRhID0gZS50YXJnZXQucmVzdWx0IHx8IG1ldGFkYXRhO1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKCEoJ2RvY19jb3VudCcgaW4gbWV0YWRhdGEpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBtZXRhZGF0YS5kb2NfY291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgnc2VxJyBpbiBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLnNlcSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghKCdkYl91dWlkJyBpbiBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLmRiX3V1aWQgPSB1dWlkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG1ldGFTdG9yZS5wdXQobWV0YWRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgb3BlblJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZXR1cCAob3BlbkRhdGFiYXNlcywgYXBpLCBvcHRzKSB7XG4gIGlmICghb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdIHx8IG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXS52ZXJzaW9uY2hhbmdlZCkge1xuICAgIG9wdHMudmVyc2lvbmNoYW5nZWQgPSBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdLnZlcnNpb25jaGFuZ2VkO1xuXG4gICAgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgb3BlbkRhdGFiYXNlKG9wZW5EYXRhYmFzZXMsIGFwaSwgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV07XG59XG5cbmZ1bmN0aW9uIGluZm8gKG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCB7XG4gICAgZG9jX2NvdW50OiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgdXBkYXRlX3NlcTogbWV0YWRhdGEuc2VxXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXQgKHR4biwgaWQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sodHhuLmVycm9yKTtcbiAgfVxuXG4gIHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgcmV2O1xuICAgIGlmICghb3B0cy5yZXYpIHtcbiAgICAgIHJldiA9IChkb2MgJiYgZG9jLnJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldiA9IG9wdHMubGF0ZXN0ID8gbGF0ZXN0KG9wdHMucmV2LCBkb2MpIDogb3B0cy5yZXY7XG4gICAgfVxuXG4gICAgaWYgKCFkb2MgfHwgKGRvYy5kZWxldGVkICYmICFvcHRzLnJldikgfHwgIShyZXYgaW4gZG9jLnJldnMpKSB7XG4gICAgICBjYWxsYmFjayhjcmVhdGVFcnJvcihNSVNTSU5HX0RPQywgJ21pc3NpbmcnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGRvYy5yZXZzW3Jldl0uZGF0YTtcbiAgICByZXN1bHQuX2lkID0gZG9jLmlkO1xuICAgIHJlc3VsdC5fcmV2ID0gcmV2O1xuXG4gICAgLy8gV0FSTklORzogZXhwZWN0aW5nIHBvc3NpYmxlIG9sZCBmb3JtYXRcbiAgICAvLyBUT0RPOiB3aHkgYXJlIHdlIHBhc3NpbmcgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBjb250ZXh0P1xuICAgIC8vICAgICAgIEl0J3Mgbm90IGNsZWFyIHdlIGV2ZXIgdGhyZWFkIHRoZXNlIHR4bnMgdXNlZnVsbHlcbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICBkb2M6IHJlc3VsdCxcbiAgICAgIG1ldGFkYXRhOiBkb2MsXG4gICAgICBjdHg6IHR4blxuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMuYmluYXJ5KSB7XG4gICAgcmV0dXJuIGNiKG51bGwsIGF0dGFjaG1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHJlYWRBc0JpbmFyeVN0cmluZyhhdHRhY2htZW50LCBmdW5jdGlvbiAoYmluU3RyaW5nKSB7XG4gICAgICBjYihudWxsLCBidG9hKGJpblN0cmluZykpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnQodHhuLCBkb2NJZCwgYXR0YWNoSWQsIF8sIG9wdHMsIGNiKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2IodHhuLmVycm9yKTtcbiAgfVxuXG4gIHZhciBhdHRhY2htZW50O1xuXG4gIHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoZG9jSWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgcmV2ID0gZG9jLnJldnNbb3B0cy5yZXYgfHwgZG9jLnJldl0uZGF0YTtcbiAgICB2YXIgZGlnZXN0ID0gcmV2Ll9hdHRhY2htZW50c1thdHRhY2hJZF0uZGlnZXN0O1xuICAgIGF0dGFjaG1lbnQgPSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XS5kYXRhO1xuICB9O1xuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXJzZUF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0cywgY2IpO1xuICB9O1xuXG4gIHR4bi50eG4ub25hYm9ydCA9IGNiO1xufVxuXG5mdW5jdGlvbiBidWxrRG9jcyAoYXBpLCByZXEsIG9wdHMsIG1ldGFkYXRhLCBkYk9wdHMsIGlkYkNoYW5nZXMsIGNhbGxiYWNrKSB7XG5cbiAgdmFyIHR4bjtcblxuICAvLyBUT0RPOiBJIHdvdWxkIHByZWZlciB0byBnZXQgcmlkIG9mIHRoZXNlIGdsb2JhbHNcbiAgdmFyIGVycm9yO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgZG9jcyA9IFtdO1xuICB2YXIgbGFzdFdyaXRlSW5kZXg7XG5cbiAgdmFyIHJldnNMaW1pdCA9IGRiT3B0cy5yZXZzX2xpbWl0IHx8IDEwMDA7XG4gIHZhciByZXdyaXRlRW5hYmxlZCA9IGRiT3B0cy5uYW1lLmluZGV4T2YoXCItbXJ2aWV3LVwiKSA9PT0gLTE7XG4gIGNvbnN0IGF1dG9Db21wYWN0aW9uID0gZGJPcHRzLmF1dG9fY29tcGFjdGlvbjtcblxuICAvLyBXZSBvbmx5IG5lZWQgdG8gdHJhY2sgMSByZXZpc2lvbiBmb3IgbG9jYWwgZG9jdW1lbnRzXG4gIGZ1bmN0aW9uIGRvY3NSZXZzTGltaXQoZG9jKSB7XG4gICAgcmV0dXJuIC9eX2xvY2FsLy50ZXN0KGRvYy5pZCkgPyAxIDogcmV2c0xpbWl0O1xuICB9XG5cbiAgZnVuY3Rpb24gcm9vdElzTWlzc2luZyhkb2MpIHtcbiAgICByZXR1cm4gZG9jLnJldl90cmVlWzBdLmlkc1sxXS5zdGF0dXMgPT09ICdtaXNzaW5nJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZTY0KGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKEJBRF9BUkcsICdBdHRhY2htZW50IGlzIG5vdCBhIHZhbGlkIGJhc2U2NCBzdHJpbmcnKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkcyB0aGUgb3JpZ2luYWwgZG9jIGZyb20gdGhlIHN0b3JlIGlmIGF2YWlsYWJsZVxuICAvLyBBcyBpbiBhbGxEb2NzIHdpdGgga2V5cyBvcHRpb24gdXNpbmcgbXVsdGlwbGUgZ2V0IGNhbGxzIGlzIHRoZSBmYXN0ZXN0IHdheVxuICBmdW5jdGlvbiBmZXRjaEV4aXN0aW5nRG9jcyh0eG4sIGRvY3MpIHtcbiAgICB2YXIgZmV0Y2hlZCA9IDA7XG4gICAgdmFyIG9sZERvY3MgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHJlYWREb25lKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC5yZXN1bHQpIHtcbiAgICAgICAgb2xkRG9jc1tlLnRhcmdldC5yZXN1bHQuaWRdID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCsrZmV0Y2hlZCA9PT0gZG9jcy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzc0RvY3ModHhuLCBkb2NzLCBvbGREb2NzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkuZ2V0KGRvYy5pZCkub25zdWNjZXNzID0gcmVhZERvbmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXZIYXNBdHRhY2htZW50KGRvYywgcmV2LCBkaWdlc3QpIHtcbiAgICByZXR1cm4gZG9jLnJldnNbcmV2XSAmJlxuICAgICAgZG9jLnJldnNbcmV2XS5kYXRhLl9hdHRhY2htZW50cyAmJlxuICAgICAgT2JqZWN0LnZhbHVlcyhkb2MucmV2c1tyZXZdLmRhdGEuX2F0dGFjaG1lbnRzKS5maW5kKGZ1bmN0aW9uIChhdHQpIHtcbiAgICAgICAgcmV0dXJuIGF0dC5kaWdlc3QgPT09IGRpZ2VzdDtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0RvY3ModHhuLCBkb2NzLCBvbGREb2NzKSB7XG5cbiAgICBkb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYywgaSkge1xuICAgICAgdmFyIG5ld0RvYztcblxuICAgICAgLy8gVGhlIGZpcnN0IGRvY3VtZW50IHdyaXRlIGNhbm5vdCBiZSBhIGRlbGV0aW9uXG4gICAgICBpZiAoJ3dhc19kZWxldGUnIGluIG9wdHMgJiYgIShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2xkRG9jcywgZG9jLmlkKSkpIHtcbiAgICAgICAgbmV3RG9jID0gY3JlYXRlRXJyb3IoTUlTU0lOR19ET0MsICdkZWxldGVkJyk7XG5cbiAgICAgIC8vIFRoZSBmaXJzdCB3cml0ZSBvZiBhIGRvY3VtZW50IGNhbm5vdCBzcGVjaWZ5IGEgcmV2aXNpb25cbiAgICAgIH0gZWxzZSBpZiAob3B0cy5uZXdfZWRpdHMgJiZcbiAgICAgICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvbGREb2NzLCBkb2MuaWQpICYmXG4gICAgICAgICAgICAgICAgIHJvb3RJc01pc3NpbmcoZG9jKSkge1xuICAgICAgICBuZXdEb2MgPSBjcmVhdGVFcnJvcihSRVZfQ09ORkxJQ1QpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGRvY3VtZW50XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvbGREb2NzLCBkb2MuaWQpKSB7XG4gICAgICAgIG5ld0RvYyA9IHVwZGF0ZSh0eG4sIGRvYywgb2xkRG9jc1tkb2MuaWRdKTtcbiAgICAgICAgLy8gVGhlIHVwZGF0ZSBjYW4gYmUgcmVqZWN0ZWQgaWYgaXQgaXMgYW4gdXBkYXRlIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgIC8vIHJldmlzaW9uLCBpZiBzbyBza2lwIGl0XG4gICAgICAgIGlmIChuZXdEb2MgPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgLy8gTmV3IGRvY3VtZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbnN1cmUgbmV3IGRvY3VtZW50cyBhcmUgYWxzbyBzdGVtbWVkXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZShbXSwgZG9jLnJldl90cmVlWzBdLCBkb2NzUmV2c0xpbWl0KGRvYykpO1xuICAgICAgICBkb2MucmV2X3RyZWUgPSBtZXJnZWQudHJlZTtcbiAgICAgICAgZG9jLnN0ZW1tZWRSZXZzID0gbWVyZ2VkLnN0ZW1tZWRSZXZzO1xuICAgICAgICBuZXdEb2MgPSBkb2M7XG4gICAgICAgIG5ld0RvYy5pc05ld0RvYyA9IHRydWU7XG4gICAgICAgIG5ld0RvYy53YXNEZWxldGVkID0gZG9jLnJldnNbZG9jLnJldl0uZGVsZXRlZCA/IDEgOiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RG9jLmVycm9yKSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSBuZXdEb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGREb2NzW25ld0RvYy5pZF0gPSBuZXdEb2M7XG4gICAgICAgIGxhc3RXcml0ZUluZGV4ID0gaTtcbiAgICAgICAgd3JpdGUodHhuLCBuZXdEb2MsIGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29udmVydHMgZnJvbSB0aGUgZm9ybWF0IHJldHVybmVkIGJ5IHBhcnNlRG9jIGludG8gdGhlIG5ldyBmb3JtYXRcbiAgLy8gd2UgdXNlIHRvIHN0b3JlXG4gIGZ1bmN0aW9uIGNvbnZlcnREb2NGb3JtYXQoZG9jKSB7XG5cbiAgICB2YXIgbmV3RG9jID0ge1xuICAgICAgaWQ6IGRvYy5tZXRhZGF0YS5pZCxcbiAgICAgIHJldjogZG9jLm1ldGFkYXRhLnJldixcbiAgICAgIHJldl90cmVlOiBkb2MubWV0YWRhdGEucmV2X3RyZWUsXG4gICAgICByZXZzOiBkb2MubWV0YWRhdGEucmV2cyB8fCB7fVxuICAgIH07XG5cbiAgICBuZXdEb2MucmV2c1tuZXdEb2MucmV2XSA9IHtcbiAgICAgIGRhdGE6IGRvYy5kYXRhLFxuICAgICAgZGVsZXRlZDogZG9jLm1ldGFkYXRhLmRlbGV0ZWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ld0RvYztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSh0eG4sIGRvYywgb2xkRG9jKSB7XG5cbiAgICAvLyBJZ25vcmUgdXBkYXRlcyB0byBleGlzdGluZyByZXZpc2lvbnNcbiAgICBpZiAoKGRvYy5yZXYgaW4gb2xkRG9jLnJldnMpICYmICFvcHRzLm5ld19lZGl0cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc1Jvb3QgPSAvXjEtLy50ZXN0KGRvYy5yZXYpO1xuXG4gICAgLy8gUmVhdHRhY2ggZmlyc3Qgd3JpdGVzIGFmdGVyIGEgZGVsZXRpb24gdG8gbGFzdCBkZWxldGVkIHRyZWVcbiAgICBpZiAob2xkRG9jLmRlbGV0ZWQgJiYgIWRvYy5kZWxldGVkICYmIG9wdHMubmV3X2VkaXRzICYmIGlzUm9vdCkge1xuICAgICAgdmFyIHRtcCA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG4gICAgICB0bXAuX3JldiA9IG9sZERvYy5yZXY7XG4gICAgICB0bXAuX2lkID0gb2xkRG9jLmlkO1xuICAgICAgZG9jID0gY29udmVydERvY0Zvcm1hdChwYXJzZURvYyh0bXAsIG9wdHMubmV3X2VkaXRzLCBkYk9wdHMpKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2Uob2xkRG9jLnJldl90cmVlLCBkb2MucmV2X3RyZWVbMF0sIGRvY3NSZXZzTGltaXQoZG9jKSk7XG4gICAgZG9jLnN0ZW1tZWRSZXZzID0gbWVyZ2VkLnN0ZW1tZWRSZXZzO1xuICAgIGRvYy5yZXZfdHJlZSA9IG1lcmdlZC50cmVlO1xuXG4gICAgLy8gTWVyZ2UgdGhlIG9sZCBhbmQgbmV3IHJldiBkYXRhXG4gICAgdmFyIHJldnMgPSBvbGREb2MucmV2cztcbiAgICByZXZzW2RvYy5yZXZdID0gZG9jLnJldnNbZG9jLnJldl07XG4gICAgZG9jLnJldnMgPSByZXZzO1xuXG4gICAgZG9jLmF0dGFjaG1lbnRzID0gb2xkRG9jLmF0dGFjaG1lbnRzO1xuXG4gICAgdmFyIGluQ29uZmxpY3QgPSBvcHRzLm5ld19lZGl0cyAmJiAoKChvbGREb2MuZGVsZXRlZCAmJiBkb2MuZGVsZXRlZCkgfHxcbiAgICAgICAoIW9sZERvYy5kZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgIT09ICduZXdfbGVhZicpIHx8XG4gICAgICAgKG9sZERvYy5kZWxldGVkICYmICFkb2MuZGVsZXRlZCAmJiBtZXJnZWQuY29uZmxpY3RzID09PSAnbmV3X2JyYW5jaCcpIHx8XG4gICAgICAgKG9sZERvYy5yZXYgPT09IGRvYy5yZXYpKSk7XG5cbiAgICBpZiAoaW5Db25mbGljdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKFJFVl9DT05GTElDVCk7XG4gICAgfVxuXG4gICAgZG9jLndhc0RlbGV0ZWQgPSBvbGREb2MuZGVsZXRlZDtcblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSh0eG4sIGRvYywgaSkge1xuXG4gICAgLy8gV2UgY29weSB0aGUgZGF0YSBmcm9tIHRoZSB3aW5uaW5nIHJldmlzaW9uIGludG8gdGhlIHJvb3RcbiAgICAvLyBvZiB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgaW5kZXhlZFxuICAgIHZhciB3aW5uaW5nUmV2JCQxID0gd2lubmluZ1Jldihkb2MpO1xuICAgIC8vIHJldiBvZiBuZXcgZG9jIGZvciBhdHRhY2htZW50cyBhbmQgdG8gcmV0dXJuIGl0XG4gICAgdmFyIHdyaXR0ZW5SZXYgPSBkb2MucmV2O1xuICAgIHZhciBpc0xvY2FsID0gL15fbG9jYWwvLnRlc3QoZG9jLmlkKTtcblxuICAgIHZhciB0aGVEb2MgPSBkb2MucmV2c1t3aW5uaW5nUmV2JCQxXS5kYXRhO1xuXG4gICAgY29uc3QgaXNOZXdEb2MgPSBkb2MuaXNOZXdEb2M7XG5cbiAgICBpZiAocmV3cml0ZUVuYWJsZWQpIHtcbiAgICAgIC8vIGRvYy5kYXRhIGlzIHdoYXQgd2UgaW5kZXgsIHNvIHdlIG5lZWQgdG8gY2xvbmUgYW5kIHJld3JpdGUgaXQsIGFuZCBjbGVhblxuICAgICAgLy8gaXQgdXAgZm9yIGluZGV4YWJpbGl0eVxuICAgICAgdmFyIHJlc3VsdCA9IHJld3JpdGUodGhlRG9jKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZG9jLmRhdGEgPSByZXN1bHQ7XG4gICAgICAgIGRlbGV0ZSBkb2MuZGF0YS5fYXR0YWNobWVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MuZGF0YSA9IHRoZURvYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLmRhdGEgPSB0aGVEb2M7XG4gICAgfVxuXG4gICAgZG9jLnJldiA9IHdpbm5pbmdSZXYkJDE7XG4gICAgLy8gLmRlbGV0ZWQgbmVlZHMgdG8gYmUgYW4gaW50IGZvciBpbmRleGluZ1xuICAgIGRvYy5kZWxldGVkID0gZG9jLnJldnNbd2lubmluZ1JldiQkMV0uZGVsZXRlZCA/IDEgOiAwO1xuXG4gICAgLy8gQnVtcCB0aGUgc2VxIGZvciBldmVyeSBuZXcgKG5vbiBsb2NhbCkgcmV2aXNpb24gd3JpdHRlblxuICAgIC8vIFRPRE86IGluZGV4IGV4cGVjdHMgYSB1bmlxdWUgc2VxLCBub3Qgc3VyZSBpZiBpZ25vcmluZyBsb2NhbCB3aWxsXG4gICAgLy8gd29ya1xuICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgZG9jLnNlcSA9ICsrbWV0YWRhdGEuc2VxO1xuXG4gICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgLy8gSWYgaXRzIGEgbmV3IGRvY3VtZW50LCB3ZSB3b250IGRlY3JlbWVudCBpZiBkZWxldGVkXG4gICAgICBpZiAoZG9jLmlzTmV3RG9jKSB7XG4gICAgICAgIGRlbHRhID0gZG9jLmRlbGV0ZWQgPyAwIDogMTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jLndhc0RlbGV0ZWQgIT09IGRvYy5kZWxldGVkKSB7XG4gICAgICAgIGRlbHRhID0gZG9jLmRlbGV0ZWQgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBtZXRhZGF0YS5kb2NfY291bnQgKz0gZGVsdGE7XG4gICAgfVxuICAgIGRlbGV0ZSBkb2MuaXNOZXdEb2M7XG4gICAgZGVsZXRlIGRvYy53YXNEZWxldGVkO1xuXG4gICAgLy8gSWYgdGhlcmUgaGF2ZSBiZWVuIHJldmlzaW9ucyBzdGVtbWVkIHdoZW4gbWVyZ2luZyB0cmVlcyxcbiAgICAvLyBkZWxldGUgdGhlaXIgZGF0YVxuICAgIGxldCByZXZzVG9EZWxldGUgPSBkb2Muc3RlbW1lZFJldnMgfHwgW107XG5cbiAgICBpZiAoYXV0b0NvbXBhY3Rpb24gJiYgIWlzTmV3RG9jKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wYWN0VHJlZShkb2MpO1xuICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV2c1RvRGVsZXRlID0gcmV2c1RvRGVsZXRlLmNvbmNhdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXZzVG9EZWxldGUubGVuZ3RoKSB7XG4gICAgICByZXZzVG9EZWxldGUuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7IGRlbGV0ZSBkb2MucmV2c1tyZXZdOyB9KTtcbiAgICB9XG5cbiAgICBkZWxldGUgZG9jLnN0ZW1tZWRSZXZzO1xuXG4gICAgaWYgKCEoJ2F0dGFjaG1lbnRzJyBpbiBkb2MpKSB7XG4gICAgICBkb2MuYXR0YWNobWVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhlRG9jLl9hdHRhY2htZW50cykge1xuICAgICAgZm9yICh2YXIgayBpbiB0aGVEb2MuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhlRG9jLl9hdHRhY2htZW50c1trXTtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnQuc3R1Yikge1xuICAgICAgICAgIGlmICghKGF0dGFjaG1lbnQuZGlnZXN0IGluIGRvYy5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgIGVycm9yID0gY3JlYXRlRXJyb3IoTUlTU0lOR19TVFVCKTtcbiAgICAgICAgICAgIC8vIFRPRE86IE5vdCBzdXJlIGhvdyBzYWZlIHRoaXMgbWFudWFsIGFib3J0IGlzLCBzZWVpbmdcbiAgICAgICAgICAgIC8vIGNvbnNvbGUgaXNzdWVzXG4gICAgICAgICAgICB0eG4uYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmV2SGFzQXR0YWNobWVudChkb2MsIHdyaXR0ZW5SZXYsIGF0dGFjaG1lbnQuZGlnZXN0KSkge1xuICAgICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzW3dyaXR0ZW5SZXZdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGRvYy5hdHRhY2htZW50c1thdHRhY2htZW50LmRpZ2VzdF0gPSBhdHRhY2htZW50O1xuICAgICAgICAgIGRvYy5hdHRhY2htZW50c1thdHRhY2htZW50LmRpZ2VzdF0ucmV2cyA9IHt9O1xuICAgICAgICAgIGRvYy5hdHRhY2htZW50c1thdHRhY2htZW50LmRpZ2VzdF0ucmV2c1t3cml0dGVuUmV2XSA9IHRydWU7XG5cbiAgICAgICAgICB0aGVEb2MuX2F0dGFjaG1lbnRzW2tdID0ge1xuICAgICAgICAgICAgc3R1YjogdHJ1ZSxcbiAgICAgICAgICAgIGRpZ2VzdDogYXR0YWNobWVudC5kaWdlc3QsXG4gICAgICAgICAgICBjb250ZW50X3R5cGU6IGF0dGFjaG1lbnQuY29udGVudF90eXBlLFxuICAgICAgICAgICAgbGVuZ3RoOiBhdHRhY2htZW50Lmxlbmd0aCxcbiAgICAgICAgICAgIHJldnBvczogcGFyc2VJbnQod3JpdHRlblJldiwgMTApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvY2FsIGRvY3VtZW50cyBoYXZlIGRpZmZlcmVudCByZXZpc2lvbiBoYW5kbGluZ1xuICAgIGlmIChpc0xvY2FsICYmIGRvYy5kZWxldGVkKSB7XG4gICAgICB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5kZWxldGUoZG9jLmlkKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgICByZXY6ICcwLTAnXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdXBkYXRlU2VxKGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLnB1dChkb2MpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICByZXY6IHdyaXR0ZW5SZXZcbiAgICAgIH07XG4gICAgICB1cGRhdGVTZXEoaSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlcShpKSB7XG4gICAgaWYgKGkgPT09IGxhc3RXcml0ZUluZGV4KSB7XG4gICAgICB0eG4ub2JqZWN0U3RvcmUoTUVUQV9TVE9SRSkucHV0KG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVQcm9jZXNzQXR0YWNobWVudChhdHRhY2htZW50KSB7XG4gICAgaWYgKGF0dGFjaG1lbnQuc3R1Yikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhdHRhY2htZW50KTtcbiAgICB9XG5cbiAgICB2YXIgYmluRGF0YTtcbiAgICBpZiAodHlwZW9mIGF0dGFjaG1lbnQuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJpbkRhdGEgPSBwYXJzZUJhc2U2NChhdHRhY2htZW50LmRhdGEpO1xuICAgICAgaWYgKGJpbkRhdGEuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGJpbkRhdGEuZXJyb3IpO1xuICAgICAgfVxuICAgICAgYXR0YWNobWVudC5kYXRhID0gYmluYXJ5U3RyaW5nVG9CbG9iT3JCdWZmZXIoYmluRGF0YSwgYXR0YWNobWVudC5jb250ZW50X3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaW5EYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgYmluYXJ5TWQ1KGJpbkRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgYXR0YWNobWVudC5kaWdlc3QgPSAnbWQ1LScgKyByZXN1bHQ7XG4gICAgICAgIGF0dGFjaG1lbnQubGVuZ3RoID0gYmluRGF0YS5zaXplIHx8IGJpbkRhdGEubGVuZ3RoIHx8IDA7XG4gICAgICAgIHJlc29sdmUoYXR0YWNobWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZVByb2Nlc3NBdHRhY2htZW50cygpIHtcbiAgICB2YXIgcHJvbWlzZXMgPSBkb2NzLm1hcChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICB2YXIgZGF0YSA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG4gICAgICBpZiAoIWRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgYXR0YWNobWVudHMgPSBPYmplY3Qua2V5cyhkYXRhLl9hdHRhY2htZW50cykubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzW2tdLm5hbWUgPSBrO1xuICAgICAgICByZXR1cm4gcHJlUHJvY2Vzc0F0dGFjaG1lbnQoZGF0YS5fYXR0YWNobWVudHNba10pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChhdHRhY2htZW50cykudGhlbihmdW5jdGlvbiAobmV3QXR0YWNobWVudHMpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IHt9O1xuICAgICAgICBuZXdBdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50KSB7XG4gICAgICAgICAgcHJvY2Vzc2VkW2F0dGFjaG1lbnQubmFtZV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgIGRlbGV0ZSBhdHRhY2htZW50Lm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLl9hdHRhY2htZW50cyA9IHByb2Nlc3NlZDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlcS5kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgZ2V0IHJpZCBvZiB0aHJvd2luZyBmb3IgaW52YWxpZCBkb2NzLCBhbHNvIG5vdCBzdXJlXG4gICAgLy8gd2h5IHRoaXMgaXMgbmVlZGVkIGluIGlkYi1uZXh0IGFuZCBub3QgaWRiXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHBhcnNlRG9jKHJlcS5kb2NzW2ldLCBvcHRzLm5ld19lZGl0cywgZGJPcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlc3VsdCA9IGVycjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLy8gSWRlYWxseSBwYXJzZURvYyB3b3VsZCByZXR1cm4gZGF0YSBpbiB0aGlzIGZvcm1hdCwgYnV0IGl0IGlzIGN1cnJlbnRseVxuICAgIC8vIHNoYXJlZCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnRcbiAgICBkb2NzLnB1c2goY29udmVydERvY0Zvcm1hdChyZXN1bHQpKTtcbiAgfVxuXG4gIHByZVByb2Nlc3NBdHRhY2htZW50cygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGFwaS5fb3BlblRyYW5zYWN0aW9uU2FmZWx5KFtET0NfU1RPUkUsIE1FVEFfU1RPUkVdLCAncmVhZHdyaXRlJywgZnVuY3Rpb24gKGVyciwgX3R4bikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHhuID0gX3R4bjtcblxuICAgICAgdHhuLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yIHx8IGNyZWF0ZUVycm9yKFVOS05PV05fRVJST1IsICd0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZCcpKTtcbiAgICAgIH07XG4gICAgICB0eG4ub250aW1lb3V0ID0gaWRiRXJyb3IoY2FsbGJhY2spO1xuXG4gICAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWRiQ2hhbmdlcy5ub3RpZnkoZGJPcHRzLm5hbWUpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFdlIHdvdWxkIGxpa2UgdG8gdXNlIHByb21pc2VzIGhlcmUsIGJ1dCBpZGIgc3Vja3NcbiAgICAgIGZldGNoRXhpc3RpbmdEb2NzKHR4biwgZG9jcyk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWxsRG9jc0tleXMoa2V5cywgZG9jU3RvcmUsIGFsbERvY3NJbm5lcikge1xuICAvLyBJdCdzIG5vdCBndWFyYW50ZWQgdG8gYmUgcmV0dXJuZWQgaW4gcmlnaHQgb3JkZXJcbiAgdmFyIHZhbHVlc0JhdGNoID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgZG9jU3RvcmUuZ2V0KGtleSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgdmFsdWVzQmF0Y2hbaW5kZXhdID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc0JhdGNoW2luZGV4XSA9IHtrZXk6IGtleSwgZXJyb3I6ICdub3RfZm91bmQnfTtcbiAgICAgIH1cbiAgICAgIGNvdW50Kys7XG4gICAgICBpZiAoY291bnQgPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc0JhdGNoLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgICAgYWxsRG9jc0lubmVyKGRvYyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlSYW5nZShzdGFydCwgZW5kLCBpbmNsdXNpdmVFbmQsIGtleSwgZGVzY2VuZGluZykge1xuICB0cnkge1xuICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5ib3VuZChlbmQsIHN0YXJ0LCAhaW5jbHVzaXZlRW5kLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSURCS2V5UmFuZ2UuYm91bmQoc3RhcnQsIGVuZCwgZmFsc2UsICFpbmNsdXNpdmVFbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKHN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoZW5kLCAhaW5jbHVzaXZlRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKGVuZCwgIWluY2x1c2l2ZUVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiBJREJLZXlSYW5nZS5vbmx5KGtleSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUtleVJhbmdlRXJyb3Iob3B0cywgbWV0YWRhdGEsIGVyciwgY2FsbGJhY2spIHtcbiAgaWYgKGVyci5uYW1lID09PSBcIkRhdGFFcnJvclwiICYmIGVyci5jb2RlID09PSAwKSB7XG4gICAgLy8gZGF0YSBlcnJvciwgc3RhcnQgaXMgbGVzcyB0aGFuIGVuZFxuICAgIHZhciByZXR1cm5WYWwgPSB7XG4gICAgICB0b3RhbF9yb3dzOiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgICBvZmZzZXQ6IG9wdHMuc2tpcCxcbiAgICAgIHJvd3M6IFtdXG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob3B0cy51cGRhdGVfc2VxKSB7XG4gICAgICByZXR1cm5WYWwudXBkYXRlX3NlcSA9IG1ldGFkYXRhLnNlcTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJldHVyblZhbCk7XG4gIH1cbiAgY2FsbGJhY2soY3JlYXRlRXJyb3IoSURCX0VSUk9SLCBlcnIubmFtZSwgZXJyLm1lc3NhZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWxsRG9jcyAodHhuLCBtZXRhZGF0YSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgLy8gVE9ETzogV2VpcmQgaGFjaywgSSBkb250IGxpa2UgaXRcbiAgaWYgKG9wdHMubGltaXQgPT09IDApIHtcbiAgICB2YXIgcmV0dXJuVmFsID0ge1xuICAgICAgdG90YWxfcm93czogbWV0YWRhdGEuZG9jX2NvdW50LFxuICAgICAgb2Zmc2V0OiBvcHRzLnNraXAsXG4gICAgICByb3dzOiBbXVxuICAgIH07XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob3B0cy51cGRhdGVfc2VxKSB7XG4gICAgICByZXR1cm5WYWwudXBkYXRlX3NlcSA9IG1ldGFkYXRhLnNlcTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJldHVyblZhbCk7XG4gIH1cblxuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuXG4gIHZhciBzdGFydCA9ICdzdGFydGtleScgaW4gb3B0cyA/IG9wdHMuc3RhcnRrZXkgOiBmYWxzZTtcbiAgdmFyIGVuZCA9ICdlbmRrZXknIGluIG9wdHMgPyBvcHRzLmVuZGtleSA6IGZhbHNlO1xuICB2YXIga2V5ID0gJ2tleScgaW4gb3B0cyA/IG9wdHMua2V5IDogZmFsc2U7XG4gIHZhciBrZXlzID0gJ2tleXMnIGluIG9wdHMgPyBvcHRzLmtleXMgOiBmYWxzZTtcbiAgdmFyIHNraXAgPSBvcHRzLnNraXAgfHwgMDtcbiAgdmFyIGxpbWl0ID0gdHlwZW9mIG9wdHMubGltaXQgPT09ICdudW1iZXInID8gb3B0cy5saW1pdCA6IC0xO1xuICB2YXIgaW5jbHVzaXZlRW5kID0gb3B0cy5pbmNsdXNpdmVfZW5kICE9PSBmYWxzZTtcbiAgdmFyIGRlc2NlbmRpbmcgPSAnZGVzY2VuZGluZycgaW4gb3B0cyAmJiBvcHRzLmRlc2NlbmRpbmcgPyAncHJldicgOiBudWxsO1xuXG4gIHZhciBrZXlSYW5nZTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5UmFuZ2UgPSBjcmVhdGVLZXlSYW5nZShzdGFydCwgZW5kLCBpbmNsdXNpdmVFbmQsIGtleSwgZGVzY2VuZGluZyk7XG4gICAgaWYgKGtleVJhbmdlICYmIGtleVJhbmdlLmVycm9yKSB7XG4gICAgICByZXR1cm4gaGFuZGxlS2V5UmFuZ2VFcnJvcihvcHRzLCBtZXRhZGF0YSwga2V5UmFuZ2UuZXJyb3IsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZG9jU3RvcmUgPSB0eG4udHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSk7XG5cbiAgdHhuLnR4bi5vbmNvbXBsZXRlID0gb25UeG5Db21wbGV0ZTtcblxuICBpZiAoa2V5cykge1xuICAgIHJldHVybiBhbGxEb2NzS2V5cyhvcHRzLmtleXMsIGRvY1N0b3JlLCBhbGxEb2NzSW5uZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZV9kb2Mocm93LCBkb2MpIHtcbiAgICB2YXIgZG9jRGF0YSA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG5cbiAgICByb3cuZG9jID0gZG9jRGF0YTtcbiAgICByb3cuZG9jLl9pZCA9IGRvYy5pZDtcbiAgICByb3cuZG9jLl9yZXYgPSBkb2MucmV2O1xuICAgIGlmIChvcHRzLmNvbmZsaWN0cykge1xuICAgICAgdmFyIGNvbmZsaWN0cyA9IGNvbGxlY3RDb25mbGljdHMoZG9jKTtcbiAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgIHJvdy5kb2MuX2NvbmZsaWN0cyA9IGNvbmZsaWN0cztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuYXR0YWNobWVudHMgJiYgZG9jRGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZG9jRGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgcHJvY2Vzc2luZy5wdXNoKHByb2Nlc3NBdHRhY2htZW50KG5hbWUsIGRvYywgcm93LmRvYywgb3B0cy5iaW5hcnkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGxEb2NzSW5uZXIoZG9jKSB7XG4gICAgaWYgKGRvYy5lcnJvciAmJiBrZXlzKSB7XG4gICAgICAvLyBrZXkgd2FzIG5vdCBmb3VuZCB3aXRoIFwia2V5c1wiIHJlcXVlc3RzXG4gICAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciByb3cgPSB7XG4gICAgICBpZDogZG9jLmlkLFxuICAgICAga2V5OiBkb2MuaWQsXG4gICAgICB2YWx1ZToge1xuICAgICAgICByZXY6IGRvYy5yZXZcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlbGV0ZWQgPSBkb2MuZGVsZXRlZDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJvdyk7XG4gICAgICAgIHJvdy52YWx1ZS5kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgcm93LmRvYyA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChza2lwLS0gPD0gMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHJvdyk7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlX2RvY3MpIHtcbiAgICAgICAgaW5jbHVkZV9kb2Mocm93LCBkb2MpO1xuICAgICAgfVxuICAgICAgaWYgKC0tbGltaXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHhuQ29tcGxldGUoKSB7XG4gICAgUHJvbWlzZS5hbGwocHJvY2Vzc2luZykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmV0dXJuVmFsID0ge1xuICAgICAgICB0b3RhbF9yb3dzOiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgcm93czogcmVzdWx0c1xuICAgICAgfTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAob3B0cy51cGRhdGVfc2VxKSB7XG4gICAgICAgIHJldHVyblZhbC51cGRhdGVfc2VxID0gbWV0YWRhdGEuc2VxO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjdXJzb3IgPSBkZXNjZW5kaW5nID9cbiAgICBkb2NTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBkZXNjZW5kaW5nKSA6XG4gICAgZG9jU3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSk7XG5cbiAgY3Vyc29yLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0ICYmIGUudGFyZ2V0LnJlc3VsdC52YWx1ZTtcblxuICAgIC8vIEhhcHBlbnMgaWYgb3B0cyBkb2VzIG5vdCBoYXZlIGxpbWl0LFxuICAgIC8vIGJlY2F1c2UgY3Vyc29yIHdpbGwgZW5kIG5vcm1hbGx5IHRoZW4sXG4gICAgLy8gd2hlbiBhbGwgZG9jcyBhcmUgcmV0cmlldmVkLlxuICAgIC8vIFdvdWxkIG5vdCBiZSBuZWVkZWQsIGlmIGdldEFsbCgpIG9wdGltaXphdGlvbiB3YXMgdXNlZCBsaWtlIGluICM2MDU5XG4gICAgaWYgKCFkb2MpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBTa2lwIGxvY2FsIGRvY3NcbiAgICBpZiAoL15fbG9jYWwvLnRlc3QoZG9jLmlkKSkge1xuICAgICAgcmV0dXJuIGUudGFyZ2V0LnJlc3VsdC5jb250aW51ZSgpO1xuICAgIH1cblxuICAgIHZhciBjb250aW51ZUN1cnNvciA9IGFsbERvY3NJbm5lcihkb2MpO1xuICAgIGlmIChjb250aW51ZUN1cnNvcikge1xuICAgICAgZS50YXJnZXQucmVzdWx0LmNvbnRpbnVlKCk7XG4gICAgfVxuICB9O1xuXG59XG5cbmZ1bmN0aW9uIGNoYW5nZXMgKHR4biwgaWRiQ2hhbmdlcywgYXBpLCBkYk9wdHMsIG9wdHMpIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBvcHRzLmNvbXBsZXRlKHR4bi5lcnJvcik7XG4gIH1cblxuICBpZiAob3B0cy5jb250aW51b3VzKSB7XG4gICAgdmFyIGlkID0gZGJPcHRzLm5hbWUgKyAnOicgKyB1dWlkKCk7XG4gICAgaWRiQ2hhbmdlcy5hZGRMaXN0ZW5lcihkYk9wdHMubmFtZSwgaWQsIGFwaSwgb3B0cyk7XG4gICAgaWRiQ2hhbmdlcy5ub3RpZnkoZGJPcHRzLm5hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWRiQ2hhbmdlcy5yZW1vdmVMaXN0ZW5lcihkYk9wdHMubmFtZSwgaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgbGltaXQgPSAnbGltaXQnIGluIG9wdHMgPyBvcHRzLmxpbWl0IDogLTE7XG4gIGlmIChsaW1pdCA9PT0gMCkge1xuICAgIGxpbWl0ID0gMTtcbiAgfVxuXG4gIHZhciBzdG9yZSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5pbmRleCgnc2VxJyk7XG5cbiAgdmFyIGZpbHRlciA9IGZpbHRlckNoYW5nZShvcHRzKTtcbiAgdmFyIHJlY2VpdmVkID0gMDtcblxuICB2YXIgbGFzdFNlcSA9IG9wdHMuc2luY2UgfHwgMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuXG4gIGZ1bmN0aW9uIG9uUmVxU3VjY2VzcyhlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5yZXN1bHQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgZG9jID0gY3Vyc29yLnZhbHVlO1xuICAgIC8vIE92ZXJ3cml0ZSBkb2MuZGF0YSwgd2hpY2ggbWF5IGhhdmUgYmVlbiByZXdyaXR0ZW4gKHNlZSByZXdyaXRlLmpzKSB3aXRoXG4gICAgLy8gdGhlIGNsZWFuIHZlcnNpb24gZm9yIHRoYXQgcmV2XG4gICAgZG9jLmRhdGEgPSBkb2MucmV2c1tkb2MucmV2XS5kYXRhO1xuICAgIGRvYy5kYXRhLl9pZCA9IGRvYy5pZDtcbiAgICBkb2MuZGF0YS5fcmV2ID0gZG9jLnJldjtcbiAgICBpZiAoZG9jLmRlbGV0ZWQpIHtcbiAgICAgIGRvYy5kYXRhLl9kZWxldGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5kb2NfaWRzICYmIG9wdHMuZG9jX2lkcy5pbmRleE9mKGRvYy5pZCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgfVxuXG4gICAgLy8gV0FSTklORzogZXhwZWN0aW5nIHBvc3NpYmxlIG9sZCBmb3JtYXRcbiAgICB2YXIgY2hhbmdlID0gb3B0cy5wcm9jZXNzQ2hhbmdlKGRvYy5kYXRhLCBkb2MsIG9wdHMpO1xuICAgIGNoYW5nZS5zZXEgPSBkb2Muc2VxO1xuICAgIGxhc3RTZXEgPSBkb2Muc2VxO1xuICAgIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihjaGFuZ2UpO1xuXG4gICAgLy8gSWYgaXRzIGFuIGVycm9yXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvcHRzLmNvbXBsZXRlKGZpbHRlcmVkKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgIHJlY2VpdmVkKys7XG4gICAgICBpZiAob3B0cy5yZXR1cm5fZG9jcykge1xuICAgICAgICByZXN1bHRzLnB1c2goY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuaW5jbHVkZV9kb2NzICYmIG9wdHMuYXR0YWNobWVudHMgJiYgZG9jLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRvYy5kYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICAgIHZhciBwID0gcHJvY2Vzc0F0dGFjaG1lbnQobmFtZSwgZG9jLCBjaGFuZ2UuZG9jLCBvcHRzLmJpbmFyeSk7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBwcm9jZXNzaW5nIHByb21pc2UgdG8gMiBhcnJheXMsIG9uZSB0cmFja3MgYWxsXG4gICAgICAgICAgLy8gdGhlIHByb21pc2VzIG5lZWRlZCBiZWZvcmUgd2UgZmlyZSBvbkNoYW5nZSwgdGhlIG90aGVyXG4gICAgICAgICAgLy8gZW5zdXJlIHdlIHByb2Nlc3MgYWxsIGF0dGFjaG1lbnRzIGJlZm9yZSBvbkNvbXBsZXRlXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcbiAgICAgICAgICBwcm9jZXNzaW5nLnB1c2gocCk7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMub25DaGFuZ2UoY2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY2VpdmVkICE9PSBsaW1pdCkge1xuICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25UeG5Db21wbGV0ZSgpIHtcbiAgICBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIG9wdHMuY29tcGxldGUobnVsbCwge1xuICAgICAgICByZXN1bHRzOiByZXN1bHRzLFxuICAgICAgICBsYXN0X3NlcTogbGFzdFNlcVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcmVxO1xuICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAgcmVxID0gc3RvcmUub3BlbkN1cnNvcihudWxsLCAncHJldicpO1xuICB9IGVsc2Uge1xuICAgIHJlcSA9IHN0b3JlLm9wZW5DdXJzb3IoSURCS2V5UmFuZ2UubG93ZXJCb3VuZChvcHRzLnNpbmNlLCB0cnVlKSk7XG4gIH1cblxuICB0eG4udHhuLm9uY29tcGxldGUgPSBvblR4bkNvbXBsZXRlO1xuICByZXEub25zdWNjZXNzID0gb25SZXFTdWNjZXNzO1xufVxuXG5mdW5jdGlvbiBnZXRSZXZpc2lvblRyZWUgKHR4biwgaWQsIGNhbGxiYWNrKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sodHhuLmVycm9yKTtcbiAgfVxuXG4gIHZhciByZXEgPSB0eG4udHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkuZ2V0KGlkKTtcbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5yZXN1bHQpIHtcbiAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGUudGFyZ2V0LnJlc3VsdC5yZXZfdHJlZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkb0NvbXBhY3Rpb24gKHR4biwgaWQsIHJldnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sodHhuLmVycm9yKTtcbiAgfVxuXG4gIHZhciBkb2NTdG9yZSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcblxuICBkb2NTdG9yZS5nZXQoaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgIHRyYXZlcnNlUmV2VHJlZShkb2MucmV2X3RyZWUsIGZ1bmN0aW9uIChpc0xlYWYsIHBvcywgcmV2SGFzaCwgY3R4LCBvcHRzKSB7XG4gICAgICB2YXIgcmV2ID0gcG9zICsgJy0nICsgcmV2SGFzaDtcbiAgICAgIGlmIChyZXZzLmluZGV4T2YocmV2KSAhPT0gLTEpIHtcbiAgICAgICAgb3B0cy5zdGF0dXMgPSAnbWlzc2luZyc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0YWNobWVudHMgPSBbXTtcblxuICAgIHJldnMuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7XG4gICAgICBpZiAocmV2IGluIGRvYy5yZXZzKSB7XG4gICAgICAgIC8vIE1ha2UgYSBsaXN0IG9mIGF0dGFjaG1lbnRzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIHJldmlzaW9ucyBiZWluZ1xuICAgICAgICAvLyBkZWxldGVkXG4gICAgICAgIGlmIChkb2MucmV2c1tyZXZdLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBkb2MucmV2c1tyZXZdLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICBhdHRhY2htZW50cy5wdXNoKGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHNba10uZGlnZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGRvYy5yZXZzW3Jldl07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBdHRhY2htZW50cyBoYXZlIGEgbGlzdCBvZiByZXZpc2lvbnMgdGhhdCBhcmUgdXNpbmcgdGhlbSwgd2hlblxuICAgIC8vIHRoYXQgbGlzdCBiZWNvbWVzIGVtcHR5IHdlIGNhbiBkZWxldGUgdGhlIGF0dGFjaG1lbnQuXG4gICAgYXR0YWNobWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZGlnZXN0KSB7XG4gICAgICByZXZzLmZvckVhY2goZnVuY3Rpb24gKHJldikge1xuICAgICAgICBkZWxldGUgZG9jLmF0dGFjaG1lbnRzW2RpZ2VzdF0ucmV2c1tyZXZdO1xuICAgICAgfSk7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGRvYy5hdHRhY2htZW50c1tkaWdlc3RdLnJldnMpLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZG9jLmF0dGFjaG1lbnRzW2RpZ2VzdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2NTdG9yZS5wdXQoZG9jKTtcbiAgfTtcblxuICB0eG4udHhuLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoZGJPcHRzLCBvcGVuRGF0YWJhc2VzLCBpZGJDaGFuZ2VzLCBjYWxsYmFjaykge1xuXG4gIGlkYkNoYW5nZXMucmVtb3ZlQWxsTGlzdGVuZXJzKGRiT3B0cy5uYW1lKTtcblxuICBmdW5jdGlvbiBkb0Rlc3Ryb3koKSB7XG4gICAgdmFyIHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk9wdHMubmFtZSk7XG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSBvcGVuRGF0YWJhc2VzW2RiT3B0cy5uYW1lXTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHtvazogdHJ1ZX0pO1xuICAgIH07XG4gIH1cblxuICAvLyBJZiB0aGUgZGF0YWJhc2UgaXMgb3BlbiB3ZSBuZWVkIHRvIGNsb3NlIGl0XG4gIGlmIChkYk9wdHMubmFtZSBpbiBvcGVuRGF0YWJhc2VzKSB7XG4gICAgb3BlbkRhdGFiYXNlc1tkYk9wdHMubmFtZV0udGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXMuaWRiLmNsb3NlKCk7XG4gICAgICBkb0Rlc3Ryb3koKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb0Rlc3Ryb3koKTtcbiAgfVxuXG59XG5cbi8vIEFkYXB0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9ub2RlX21vZHVsZXMvcG91Y2hkYi1maW5kL3NyYy9hZGFwdGVycy9sb2NhbC9maW5kL3F1ZXJ5LXBsYW5uZXIuanMjTDIwLUwyNFxuLy8gVGhpcyBjb3VsZCBjaGFuZ2UgLyBpbXByb3ZlIGluIHRoZSBmdXR1cmU/XG52YXIgQ09VQ0hfQ09MTEFURV9MTyA9IG51bGw7XG52YXIgQ09VQ0hfQ09MTEFURV9ISSA9ICdcXHVmZmZmJzsgLy8gYWN0dWFsbHkgdXNlZCBhcyB7XCJcXHVmZmZmXCI6IHt9fVxuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREIvI2NvbXBhcmUtdHdvLWtleXNcbi8vIEltcG9ydGFudGx5LCAqdGhlcmUgaXMgbm8gdXBwZXIgYm91bmQgcG9zc2libGUqIGluIGlkYi4gVGhlIGlkZWFsIGRhdGFcbi8vIHN0cnVjdHVyZSBhbiBpbmZpbnRlbHkgZGVlcCBhcnJheTpcbi8vICAgdmFyIElEQl9DT0xMQVRFX0hJID0gW107IElEQl9DT0xMQVRFX0hJLnB1c2goSURCX0NPTExBVEVfSEkpXG4vLyBCdXQgSURCS2V5UmFuZ2UgaXMgbm90IGEgZmFuIG9mIHNoZW5hbmlnYW5zLCBzbyBJJ3ZlIGp1c3QgZ29uZSB3aXRoIDEyIGxheWVyc1xuLy8gYmVjYXVzZSBpdCBsb29rcyBuaWNlIGFuZCBzdXJlbHkgdGhhdCdzIGVub3VnaCFcbnZhciBJREJfQ09MTEFURV9MTyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbnZhciBJREJfQ09MTEFURV9ISSA9IFtbW1tbW1tbW1tbW11dXV1dXV1dXV1dXTtcblxuLy9cbi8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIG1hZGUgb2ZmaWNhbCBzb21ld2hlcmUgYW5kIHVzZWQgYnkgQWxsRG9jcyAvIGdldCAvXG4vLyBjaGFuZ2VzIGV0YyBhcyB3ZWxsLlxuLy9cbmZ1bmN0aW9uIGV4dGVybmFsaXNlUmVjb3JkKGlkYkRvYykge1xuICB2YXIgZG9jID0gaWRiRG9jLnJldnNbaWRiRG9jLnJldl0uZGF0YTtcbiAgZG9jLl9pZCA9IGlkYkRvYy5pZDtcbiAgZG9jLl9yZXYgPSBpZGJEb2MucmV2O1xuICBpZiAoaWRiRG9jLmRlbGV0ZWQpIHtcbiAgICBkb2MuX2RlbGV0ZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRvYztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXlyYW5nZSBiYXNlZCBvbiB0aGUgb3B0cyBwYXNzZWQgdG8gcXVlcnlcbiAqXG4gKiBUaGUgZmlyc3Qga2V5IGlzIGFsd2F5cyAwLCBhcyB0aGF0J3MgaG93IHdlJ3JlIGZpbHRlcmluZyBvdXQgZGVsZXRlZCBlbnRyaWVzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVJhbmdlKG9wdHMpIHtcbiAgZnVuY3Rpb24gZGVmaW5lZChvYmosIGspIHtcbiAgICByZXR1cm4gb2JqW2tdICE9PSB2b2lkIDA7XG4gIH1cblxuICAvLyBDb252ZXJ0cyBhIHZhbGlkIENvdWNoREIga2V5IGludG8gYSB2YWxpZCBJbmRleGVkREIgb25lXG4gIGZ1bmN0aW9uIGNvbnZlcnQoa2V5LCBleGFjdCkge1xuICAgIC8vIFRoZSBmaXJzdCBpdGVtIGluIGV2ZXJ5IG5hdGl2ZSBpbmRleCBpcyBkb2MuZGVsZXRlZCwgYW5kIHdlIGFsd2F5cyB3YW50XG4gICAgLy8gdG8gb25seSBzZWFyY2ggZG9jdW1lbnRzIHRoYXQgYXJlIG5vdCBkZWxldGVkLlxuICAgIC8vIFwiZm9vXCIgLT4gWzAsIFwiZm9vXCJdXG4gICAgdmFyIGZpbHRlckRlbGV0ZWQgPSBbMF0uY29uY2F0KGtleSk7XG5cbiAgICByZXR1cm4gZmlsdGVyRGVsZXRlZC5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIC8vIG51bGwsIHRydWUgYW5kIGZhbHNlIGFyZSBub3QgaW5kZXhhYmxlIGJ5IGluZGV4ZWRkYi4gV2hlbiB3ZSB3cml0ZVxuICAgICAgLy8gdGhlc2UgdmFsdWVzIHdlIGNvbnZlcnQgdGhlbSB0byB0aGVzZSBjb25zdGFudHMsIGFuZCBzbyB3aGVuIHdlXG4gICAgICAvLyBxdWVyeSBmb3IgdGhlbSB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIHF1ZXJ5IGFsc28uXG4gICAgICBpZiAoayA9PT0gbnVsbCAmJiBleGFjdCkge1xuICAgICAgICAvLyBmb3Igbm9uLWV4YWN0IHF1ZXJpZXMgd2UgdHJlYXQgbnVsbCBhcyBhIGNvbGxhdGUgcHJvcGVydHlcbiAgICAgICAgLy8gc2VlIGBpZiAoIWV4YWN0KWAgYmxvY2sgYmVsb3dcbiAgICAgICAgcmV0dXJuIElEQl9OVUxMO1xuICAgICAgfSBlbHNlIGlmIChrID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBJREJfVFJVRTtcbiAgICAgIH0gZWxzZSBpZiAoayA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIElEQl9GQUxTRTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGFjdCkge1xuICAgICAgICAvLyBXZSBnZXQgcGFzc2VkIENvdWNoREIncyBjb2xsYXRlIGxvdyBhbmQgaGlnaCB2YWx1ZXMsIHNvIGZvciBub24tZXhhY3RcbiAgICAgICAgLy8gcmFuZ2VkIHF1ZXJpZXMgd2UncmUgZ29pbmcgdG8gY29udmVydCB0aGVtIHRvIG91ciBJREIgZXF1aXZhbGVudHNcbiAgICAgICAgaWYgKGsgPT09IENPVUNIX0NPTExBVEVfTE8pIHtcbiAgICAgICAgICByZXR1cm4gSURCX0NPTExBVEVfTE87XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGssIENPVUNIX0NPTExBVEVfSEkpKSB7XG4gICAgICAgICAgcmV0dXJuIElEQl9DT0xMQVRFX0hJO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ291Y2hEQiBhbmQgc28gUG91Y2hkQiBkZWZhdWx0cyB0byB0cnVlLiBXZSBuZWVkIHRvIG1ha2UgdGhpcyBleHBsaWNpdCBhc1xuICAvLyB3ZSBpbnZlcnQgdGhlc2UgbGF0ZXIgZm9yIEluZGV4ZWREQi5cbiAgaWYgKCFkZWZpbmVkKG9wdHMsICdpbmNsdXNpdmVfZW5kJykpIHtcbiAgICBvcHRzLmluY2x1c2l2ZV9lbmQgPSB0cnVlO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRzLCAnaW5jbHVzaXZlX3N0YXJ0JykpIHtcbiAgICBvcHRzLmluY2x1c2l2ZV9zdGFydCA9IHRydWU7XG4gIH1cblxuICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAgLy8gRmxpcCBiZWZvcmUgZ2VuZXJhdGluZy4gV2UnbGwgY2hlY2sgZGVzY2VuZGluZyBhZ2FpbiBsYXRlciB3aGVuIHBlcmZvcm1pbmdcbiAgICAvLyBhbiBpbmRleCByZXF1ZXN0XG4gICAgdmFyIHJlYWxFbmRrZXkgPSBvcHRzLnN0YXJ0a2V5LFxuICAgICAgICByZWFsSW5jbHVzaXZlRW5kID0gb3B0cy5pbmNsdXNpdmVfc3RhcnQ7XG5cbiAgICBvcHRzLnN0YXJ0a2V5ID0gb3B0cy5lbmRrZXk7XG4gICAgb3B0cy5lbmRrZXkgPSByZWFsRW5ka2V5O1xuICAgIG9wdHMuaW5jbHVzaXZlX3N0YXJ0ID0gb3B0cy5pbmNsdXNpdmVfZW5kO1xuICAgIG9wdHMuaW5jbHVzaXZlX2VuZCA9IHJlYWxJbmNsdXNpdmVFbmQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChkZWZpbmVkKG9wdHMsICdrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoY29udmVydChvcHRzLmtleSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmIChkZWZpbmVkKG9wdHMsICdzdGFydGtleScpICYmICFkZWZpbmVkKG9wdHMsICdlbmRrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoY29udmVydChvcHRzLnN0YXJ0a2V5KSwgIW9wdHMuaW5jbHVzaXZlX3N0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZmluZWQob3B0cywgJ3N0YXJ0a2V5JykgJiYgZGVmaW5lZChvcHRzLCAnZW5ka2V5JykpIHtcbiAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKGNvbnZlcnQob3B0cy5lbmRrZXkpLCAhb3B0cy5pbmNsdXNpdmVfZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmaW5lZChvcHRzLCAnc3RhcnRrZXknKSAmJiBkZWZpbmVkKG9wdHMsICdlbmRrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKFxuICAgICAgICBjb252ZXJ0KG9wdHMuc3RhcnRrZXkpLCAgICBjb252ZXJ0KG9wdHMuZW5ka2V5KSxcbiAgICAgICAgIW9wdHMuaW5jbHVzaXZlX3N0YXJ0LCAhb3B0cy5pbmNsdXNpdmVfZW5kXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBJREJLZXlSYW5nZS5vbmx5KFswXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBnZW5lcmF0ZSBrZXlSYW5nZScsIGVyciwgb3B0cyk7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZW5lcmF0ZSBrZXkgcmFuZ2Ugd2l0aCAnICsgSlNPTi5zdHJpbmdpZnkob3B0cykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4SGFuZGxlKHBkYiwgZmllbGRzLCByZWplY3QpIHtcbiAgdmFyIGluZGV4TmFtZSA9IG5hdHVyYWxJbmRleE5hbWUoZmllbGRzKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBwZGIuX29wZW5UcmFuc2FjdGlvblNhZmVseShbRE9DX1NUT1JFXSwgJ3JlYWRvbmx5JywgZnVuY3Rpb24gKGVyciwgdHhuKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBpZGJFcnJvcihyZWplY3QpKGVycik7XG4gICAgICB9XG5cbiAgICAgIHR4bi5vbmFib3J0ID0gaWRiRXJyb3IocmVqZWN0KTtcbiAgICAgIHR4bi5vbnRpbWVvdXQgPSBpZGJFcnJvcihyZWplY3QpO1xuXG4gICAgICB2YXIgZXhpc3RpbmdJbmRleE5hbWVzID0gQXJyYXkuZnJvbSh0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5pbmRleE5hbWVzKTtcblxuICAgICAgaWYgKGV4aXN0aW5nSW5kZXhOYW1lcy5pbmRleE9mKGluZGV4TmFtZSkgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZSBpbmRleCBpcyBtaXNzaW5nLCBmb3JjZSBhIGRiIHJlc3RhcnQgYW5kIHRyeSBhZ2FpblxuICAgICAgICBwZGIuX2ZyZXNoZW4oKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEluZGV4SGFuZGxlKHBkYiwgZmllbGRzLCByZWplY3QpOyB9KVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5pbmRleChpbmRleE5hbWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIEluIHRoZW9yeSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBsaWtlIHRoZSBkb2MgZXhhbXBsZSBiZWxvdywgYnV0IGZpbmRcbi8vIG9ubHkgbmVlZHMgcm93czogW3tkb2M6IHsuLi59fV0sIHNvIEkgdGhpbmsgd2UgY2FuIGp1c3Qgbm90IGJvdGhlciBmb3Igbm93XG4vLyB7XG4vLyAgIFwib2Zmc2V0XCIgOiAwLFxuLy8gICBcInJvd3NcIjogW3tcbi8vICAgICBcImlkXCI6IFwiZG9jM1wiLFxuLy8gICAgIFwia2V5XCI6IFwiTGlzYSBTYXlzXCIsXG4vLyAgICAgXCJ2YWx1ZVwiOiBudWxsLFxuLy8gICAgIFwiZG9jXCI6IHtcbi8vICAgICAgIFwiX2lkXCI6IFwiZG9jM1wiLFxuLy8gICAgICAgXCJfcmV2XCI6IFwiMS16XCIsXG4vLyAgICAgICBcInRpdGxlXCI6IFwiTGlzYSBTYXlzXCJcbi8vICAgICB9XG4vLyAgIH1dLFxuLy8gICBcInRvdGFsX3Jvd3NcIiA6IDRcbi8vIH1cbmZ1bmN0aW9uIHF1ZXJ5KGlkYiwgc2lnbmF0dXJlLCBvcHRzKSB7XG4gIC8vIEF0IHRoaXMgc3RhZ2UsIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCBmaW5kIGhhcyBhbHJlYWR5IGdvbmUgdGhyb3VnaFxuICAvLyBhbmQgZGV0ZXJtaW5lZCBpZiB0aGUgaW5kZXggYWxyZWFkeSBleGlzdHMgZnJvbSBQb3VjaERCJ3MgcGVyc3BlY3RpdmUgKGVnXG4gIC8vIHRoZXJlIGlzIGEgZGVzaWduIGRvYyBmb3IgaXQpLlxuICAvL1xuICAvLyBJZiB3ZSBmaW5kIHRoYXQgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIGNsb3NlIGFuZFxuICAvLyByZS1vcGVuIHRoZSBEQiB0byBjb3JyZWN0IGluZGV4ZXMgYmVmb3JlIHByb2NlZWRpbmcsIGF0IHdoaWNoIHBvaW50IHRoZVxuICAvLyBpbmRleCBzaG91bGQgZXhpc3QuXG5cbiAgdmFyIHBkYiA9IHRoaXM7XG5cbiAgLy8gQXNzdW1wdGlvbiwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSAvLCBiZXR3ZWVuIHRoZSBkZXNpZ24gZG9jdW1lbnQgbmFtZVxuICAvLyBhbmQgdGhlIHZpZXcgbmFtZS5cbiAgdmFyIHBhcnRzID0gc2lnbmF0dXJlLnNwbGl0KCcvJyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBwZGIuZ2V0KCdfZGVzaWduLycgKyBwYXJ0c1swXSkudGhlbihmdW5jdGlvbiAoZGRvYykge1xuICAgICAgdmFyIGZpZWxkcyA9IHJhd0luZGV4RmllbGRzKGRkb2MsIHBhcnRzWzFdKTtcbiAgICAgIGlmICghZmllbGRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGRvYyAnICsgZGRvYy5faWQgKycgd2l0aCB2aWV3ICcgKyBwYXJ0c1sxXSArXG4gICAgICAgICAgJyBkb2VzIG5vdCBoYXZlIG1hcC5vcHRpb25zLmRlZi5maWVsZHMgZGVmaW5lZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNraXAgPSBvcHRzLnNraXA7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIuaXNJbnRlZ2VyKG9wdHMubGltaXQpICYmIG9wdHMubGltaXQ7XG5cbiAgICAgIHJldHVybiBnZXRJbmRleEhhbmRsZShwZGIsIGZpZWxkcywgcmVqZWN0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5kZXhIYW5kbGUpIHtcbiAgICAgICAgICB2YXIga2V5UmFuZ2UgPSBnZW5lcmF0ZUtleVJhbmdlKG9wdHMpO1xuICAgICAgICAgIHZhciByZXEgPSBpbmRleEhhbmRsZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBvcHRzLmRlc2NlbmRpbmcgPyAncHJldicgOiAnbmV4dCcpO1xuXG4gICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGlkYkVycm9yKHJlamVjdCk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoIWN1cnNvciB8fCBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgcm93czogcm93c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uoc2tpcCk7XG4gICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgICAgbGltaXQgPSBsaW1pdCAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvd3MucHVzaCh7ZG9jOiBleHRlcm5hbGlzZVJlY29yZChjdXJzb3IudmFsdWUpfSk7XG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gdmlld0NsZWFudXAoKSB7XG4gIC8vIEknbSBub3Qgc3VyZSB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIGhlcmUuXG4gIC8vXG4gIC8vIE9uZSBvcHRpb24gaXMgdG8ganVzdCBjbG9zZSBhbmQgcmUtb3BlbiB0aGUgREIsIHdoaWNoIHBlcmZvcm1zIHRoZSBzYW1lXG4gIC8vIGFjdGlvbi4gVGhlIG9ubHkgcmVhc29uIHlvdSdkIHdhbnQgdG8gY2FsbCB0aGlzIGlzIGlmIHlvdSBkZWxldGVkIGEgYnVuY2hcbiAgLy8gb2YgaW5kZXhlcyBhbmQgd2FudGVkIHRoZSBzcGFjZSBiYWNrIGltbWVkaWF0ZWx5LlxuICAvL1xuICAvLyBPdGhlcndpc2UgaW5kZXggY2xlYW51cCBoYXBwZW5zIHdoZW46XG4gIC8vICAtIEEgREIgaXMgb3BlbmVkXG4gIC8vICAtIEEgZmluZCBxdWVyeSBpcyBwZXJmb3JtZWQgYWdhaW5zdCBhbiBpbmRleCB0aGF0IGRvZXNuJ3QgZXhpc3QgYnV0IHNob3VsZFxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxudmFyIEFEQVBURVJfTkFNRSA9ICdpbmRleGVkZGInO1xuXG4vLyBUT0RPOiBDb25zdHJ1Y3RvciBzaG91bGQgYmUgY2FwaXRhbGlzZWRcbnZhciBpZGJDaGFuZ2VzID0gbmV3IGNoYW5nZXNIYW5kbGVyKCk7XG5cbi8vIEEgc2hhcmVkIGxpc3Qgb2YgZGF0YWJhc2UgaGFuZGxlc1xudmFyIG9wZW5EYXRhYmFzZXMgPSB7fTtcblxuZnVuY3Rpb24gSWRiUG91Y2goZGJPcHRzLCBjYWxsYmFjaykge1xuXG4gIGlmIChkYk9wdHMudmlld19hZGFwdGVyKSB7XG4gICAgY29uc29sZS5sb2coJ1BsZWFzZSBub3RlIHRoYXQgdGhlIGluZGV4ZWRkYiBhZGFwdGVyIG1hbmFnZXMgX2ZpbmQgaW5kZXhlcyBpdHNlbGYsIHRoZXJlZm9yZSBpdCBpcyBub3QgdXNpbmcgeW91ciBzcGVjaWZpZWQgdmlld19hZGFwdGVyJyk7XG4gIH1cbiAgXG4gIHZhciBhcGkgPSB0aGlzO1xuICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAvLyBXcmFwcGVyIHRoYXQgZ2l2ZXMgeW91IGFuIGFjdGl2ZSBEQiBoYW5kbGUuIFlvdSBwcm9iYWJseSB3YW50ICR0LlxuICB2YXIgJCA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgc2V0dXAob3BlbkRhdGFiYXNlcywgYXBpLCBkYk9wdHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBtZXRhZGF0YSA9IHJlcy5tZXRhZGF0YTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHJlcy5pZGIpO1xuICAgICAgICBmdW4uYXBwbHkoYXBpLCBhcmdzKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBhcmdzLnBvcCgpO1xuICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICAvLyB0aGUgcHJvbWlzZSB2ZXJzaW9uIG9mICRcbiAgdmFyICRwID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgIHJldHVybiBzZXR1cChvcGVuRGF0YWJhc2VzLCBhcGksIGRiT3B0cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIG1ldGFkYXRhID0gcmVzLm1ldGFkYXRhO1xuICAgICAgICBhcmdzLnVuc2hpZnQocmVzLmlkYik7XG5cbiAgICAgICAgcmV0dXJuIGZ1bi5hcHBseShhcGksIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgLy8gV3JhcHBlciB0aGF0IGdpdmVzIHlvdSBhIHNhZmUgdHJhbnNhY3Rpb24gaGFuZGxlLiBJdCdzIGltcG9ydGFudCB0byB1c2VcbiAgLy8gdGhpcyBpbnN0ZWFkIG9mIG9wZW5pbmcgeW91ciBvd24gdHJhbnNhY3Rpb24gZnJvbSBhIGRiIGhhbmRsZSBnb3QgZnJvbSAkLFxuICAvLyBiZWNhdXNlIGluIHRoZSB0aW1lIGJldHdlZW4gZ2V0dGluZyB0aGUgZGIgaGFuZGxlIGFuZCBvcGVuaW5nIHRoZVxuICAvLyB0cmFuc2FjdGlvbiBpdCBtYXkgaGF2ZSBiZWVuIGludmFsaWRhdGVkIGJ5IGluZGV4IGNoYW5nZXMuXG4gIHZhciAkdCA9IGZ1bmN0aW9uIChmdW4sIHN0b3JlcywgbW9kZSkge1xuICAgIHN0b3JlcyA9IHN0b3JlcyB8fCBbRE9DX1NUT1JFXTtcbiAgICBtb2RlID0gbW9kZSB8fCAncmVhZG9ubHknO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHZhciB0eG4gPSB7fTtcbiAgICAgIHNldHVwKG9wZW5EYXRhYmFzZXMsIGFwaSwgZGJPcHRzKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgbWV0YWRhdGEgPSByZXMubWV0YWRhdGE7XG4gICAgICAgIHR4bi50eG4gPSByZXMuaWRiLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBlc3RhYmxpc2ggdHJhbnNhY3Rpb24gc2FmZWx5Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgdHhuLmVycm9yID0gZXJyO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0eG4pO1xuICAgICAgICBmdW4uYXBwbHkoYXBpLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgYXBpLl9vcGVuVHJhbnNhY3Rpb25TYWZlbHkgPSBmdW5jdGlvbiAoc3RvcmVzLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICR0KGZ1bmN0aW9uICh0eG4sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh0eG4uZXJyb3IsIHR4bi50eG4pO1xuICAgIH0sIHN0b3JlcywgbW9kZSkoY2FsbGJhY2spO1xuICB9O1xuXG4gIGFwaS5fcmVtb3RlID0gZmFsc2U7XG4gIGFwaS50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQURBUFRFUl9OQU1FOyB9O1xuXG4gIGFwaS5faWQgPSAkKGZ1bmN0aW9uIChfLCBjYikge1xuICAgIGNiKG51bGwsIG1ldGFkYXRhLmRiX3V1aWQpO1xuICB9KTtcblxuICBhcGkuX2luZm8gPSAkKGZ1bmN0aW9uIChfLCBjYikge1xuICAgIHJldHVybiBpbmZvKG1ldGFkYXRhLCBjYik7XG4gIH0pO1xuXG4gIGFwaS5fZ2V0ID0gJHQoZ2V0KTtcblxuICBhcGkuX2J1bGtEb2NzID0gJChmdW5jdGlvbiAoXywgcmVxLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGJ1bGtEb2NzKGFwaSwgcmVxLCBvcHRzLCBtZXRhZGF0YSwgZGJPcHRzLCBpZGJDaGFuZ2VzLCBjYWxsYmFjayk7XG4gIH0pO1xuXG4gIGFwaS5fYWxsRG9jcyA9ICR0KGZ1bmN0aW9uICh0eG4sIG9wdHMsIGNiKSB7XG4gICAgYWxsRG9jcyh0eG4sIG1ldGFkYXRhLCBvcHRzLCBjYik7XG4gIH0pO1xuXG4gIGFwaS5fZ2V0QXR0YWNobWVudCA9ICR0KGdldEF0dGFjaG1lbnQpO1xuXG4gIGFwaS5fY2hhbmdlcyA9ICR0KGZ1bmN0aW9uICh0eG4sIG9wdHMpIHtcbiAgICBjaGFuZ2VzKHR4biwgaWRiQ2hhbmdlcywgYXBpLCBkYk9wdHMsIG9wdHMpO1xuICB9KTtcblxuICBhcGkuX2dldFJldmlzaW9uVHJlZSA9ICR0KGdldFJldmlzaW9uVHJlZSk7XG4gIGFwaS5fZG9Db21wYWN0aW9uID0gJHQoZG9Db21wYWN0aW9uLCBbRE9DX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuXG4gIGFwaS5fY3VzdG9tRmluZEFic3RyYWN0TWFwcGVyID0ge1xuICAgIHF1ZXJ5OiAkcChxdWVyeSksXG4gICAgdmlld0NsZWFudXA6ICRwKHZpZXdDbGVhbnVwKVxuICB9O1xuXG4gIGFwaS5fZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkZXN0cm95KGRiT3B0cywgb3BlbkRhdGFiYXNlcywgaWRiQ2hhbmdlcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGFwaS5fY2xvc2UgPSAkKGZ1bmN0aW9uIChkYiwgY2IpIHtcbiAgICBkZWxldGUgb3BlbkRhdGFiYXNlc1tkYk9wdHMubmFtZV07XG4gICAgZGIuY2xvc2UoKTtcbiAgICBjYigpO1xuICB9KTtcblxuICAvLyBDbG9zaW5nIGFuZCByZS1vcGVuaW5nIHRoZSBEQiByZS1nZW5lcmF0ZXMgbmF0aXZlIGluZGV4ZXNcbiAgYXBpLl9mcmVzaGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgYXBpLl9jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICQocmVzb2x2ZSkoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE86IHRoaXMgc2V0VGltZW91dCBzZWVtcyBuYXN0eSwgaWYgaXRzIG5lZWRlZCBsZXRzXG4gIC8vIGZpZ3VyZSBvdXQgLyBleHBsYWluIHdoeVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBhcGkpO1xuICB9KTtcbn1cblxuLy8gVE9ETzogdGhpcyBpc250IHJlYWxseSB2YWxpZCBwZXJtYW5lbnRseSwganVzdCBiZWluZyBsYXp5IHRvIHN0YXJ0XG5JZGJQb3VjaC52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpbmRleCAoUG91Y2hEQikge1xuICBQb3VjaERCLmFkYXB0ZXIoQURBUFRFUl9OQU1FLCBJZGJQb3VjaCwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js\n");

/***/ })

}]);